CCS PCH C Compiler, Version 5.015, 5967               18-Jun-14 12:10

               Filename:   F:\PROJECT\CCSPIC\RFID-USB\RFIDReader.lst

               ROM used:   6046 bytes (18%)
                           Largest free fragment is 26722
               RAM used:   236 (12%) at main() level
                           269 (13%) worst case
               Stack used: 12 locations (3 in main + 9 for interrupts)
               Stack size: 31

*
0000:  GOTO   15E8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  FF2.5
004A:  GOTO   0054
004E:  BTFSC  FF2.2
0050:  GOTO   0F2E
0054:  BTFSS  F9D.2
0056:  GOTO   0060
005A:  BTFSC  F9E.2
005C:  GOTO   0D3E
0060:  BTFSS  FA0.0
0062:  GOTO   006C
0066:  BTFSC  FA1.0
0068:  GOTO   0EC6
006C:  BTFSS  FA0.5
006E:  GOTO   0078
0072:  BTFSC  FA1.5
0074:  GOTO   0CCC
0078:  MOVFF  0E,00
007C:  MOVFF  0F,01
0080:  MOVFF  10,02
0084:  MOVFF  11,03
0088:  MOVFF  0C,FE9
008C:  MOVFF  07,FEA
0090:  BSF    07.7
0092:  MOVFF  08,FE1
0096:  MOVFF  09,FE2
009A:  MOVFF  0A,FD9
009E:  MOVFF  0B,FDA
00A2:  MOVFF  12,FF3
00A6:  MOVFF  13,FF4
00AA:  MOVFF  14,FFA
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include <RFIDReader.h> 
.................... #include <18F2550.h> 
.................... //////////// Standard Header file for the PIC18F2550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2013 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2550 
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 00,03
00CC:  DATA FF,FF
00CE:  DATA FF,FF
00D0:  DATA FF,FF
00D2:  DATA FF,FF
00D4:  DATA FF,FF
00D6:  DATA FF,FF
00D8:  DATA FF,FF
00DA:  CLRF   FF7
00DC:  ADDLW  EA
00DE:  MOVWF  FF6
00E0:  MOVLW  00
00E2:  ADDWFC FF7,F
00E4:  TBLRD*+
00E6:  MOVF   FF5,W
00E8:  RETURN 0
00EA:  DATA 40,00
00EC:  DATA 03,00
00EE:  DATA 00,00
00F0:  DATA 00,00
00F2:  DATA 00,00
00F4:  DATA 00,00
00F6:  DATA 00,00
00F8:  DATA 00,00
00FA:  DATA 00,00
00FC:  DATA 00,00
00FE:  DATA 00,00
0100:  DATA 00,00
0102:  DATA 00,00
0104:  DATA 00,00
0106:  DATA 00,00
0108:  DATA 00,00
010A:  CLRF   FF7
010C:  ADDLW  1A
010E:  MOVWF  FF6
0110:  MOVLW  01
0112:  ADDWFC FF7,F
0114:  TBLRD*+
0116:  MOVF   FF5,W
0118:  RETURN 0
011A:  DATA 06,00
011C:  DATA FF,09
011E:  DATA 01,A1
0120:  DATA 01,19
0122:  DATA 01,29
0124:  DATA 08,15
0126:  DATA 80,25
0128:  DATA 7F,75
012A:  DATA 08,95
012C:  DATA 02,81
012E:  DATA 02,19
0130:  DATA 01,29
0132:  DATA 08,75
0134:  DATA 08,95
0136:  DATA 02,91
0138:  DATA 02,C0
013A:  CLRF   FF7
013C:  ADDLW  4A
013E:  MOVWF  FF6
0140:  MOVLW  01
0142:  ADDWFC FF7,F
0144:  TBLRD*+
0146:  MOVF   FF5,W
0148:  RETURN 0
014A:  DATA 00,00
014C:  CLRF   FF7
014E:  ADDLW  5C
0150:  MOVWF  FF6
0152:  MOVLW  01
0154:  ADDWFC FF7,F
0156:  TBLRD*+
0158:  MOVF   FF5,W
015A:  RETURN 0
015C:  DATA 20,00
015E:  CLRF   FF7
0160:  ADDLW  6E
0162:  MOVWF  FF6
0164:  MOVLW  01
0166:  ADDWFC FF7,F
0168:  TBLRD*+
016A:  MOVF   FF5,W
016C:  RETURN 0
016E:  DATA 09,02
0170:  DATA 29,00
0172:  DATA 01,01
0174:  DATA 00,80
0176:  DATA 32,09
0178:  DATA 04,00
017A:  DATA 00,02
017C:  DATA 03,00
017E:  DATA 00,00
0180:  DATA 09,21
0182:  DATA 00,01
0184:  DATA 00,01
0186:  DATA 22,20
0188:  DATA 00,07
018A:  DATA 05,81
018C:  DATA 03,03
018E:  DATA 00,0A
0190:  DATA 07,05
0192:  DATA 01,03
0194:  DATA 03,00
0196:  DATA 0A,00
0198:  CLRF   FF7
019A:  ADDLW  A8
019C:  MOVWF  FF6
019E:  MOVLW  01
01A0:  ADDWFC FF7,F
01A2:  TBLRD*+
01A4:  MOVF   FF5,W
01A6:  RETURN 0
01A8:  DATA 01,00
01AA:  CLRF   FF7
01AC:  ADDLW  BA
01AE:  MOVWF  FF6
01B0:  MOVLW  01
01B2:  ADDWFC FF7,F
01B4:  TBLRD*+
01B6:  MOVF   FF5,W
01B8:  RETURN 0
01BA:  DATA 12,00
01BC:  CLRF   FF7
01BE:  ADDLW  CC
01C0:  MOVWF  FF6
01C2:  MOVLW  01
01C4:  ADDWFC FF7,F
01C6:  TBLRD*+
01C8:  MOVF   FF5,W
01CA:  RETURN 0
01CC:  DATA 12,01
01CE:  DATA 10,01
01D0:  DATA 00,00
01D2:  DATA 00,40
01D4:  DATA 61,04
01D6:  DATA 20,00
01D8:  DATA 00,01
01DA:  DATA 01,02
01DC:  DATA 00,01
01DE:  CLRF   FF7
01E0:  ADDLW  EE
01E2:  MOVWF  FF6
01E4:  MOVLW  01
01E6:  ADDWFC FF7,F
01E8:  TBLRD*+
01EA:  MOVF   FF5,W
01EC:  RETURN 0
01EE:  DATA 04,03
01F0:  DATA 09,04
01F2:  DATA 08,03
01F4:  DATA 43,00
01F6:  DATA 43,00
01F8:  DATA 53,00
01FA:  DATA 1A,03
01FC:  DATA 43,00
01FE:  DATA 43,00
0200:  DATA 53,00
0202:  DATA 20,00
0204:  DATA 48,00
0206:  DATA 49,00
0208:  DATA 44,00
020A:  DATA 20,00
020C:  DATA 44,00
020E:  DATA 65,00
0210:  DATA 6D,00
0212:  DATA 6F,00
*
0428:  ADDWF  FE8,W
042A:  CLRF   FF7
042C:  RLCF   FF7,F
042E:  ADDLW  43
0430:  MOVWF  FF6
0432:  MOVLW  04
0434:  ADDWFC FF7,F
0436:  TBLRD*-
0438:  MOVF   FF5,W
043A:  MOVWF  FFA
043C:  TBLRD*
043E:  MOVF   FF5,W
0440:  MOVWF  FF9
0442:  DATA 98,03
0444:  DATA AE,03
0446:  DATA C4,03
0448:  DATA DA,03
*
0EA4:  ADDWF  FE8,W
0EA6:  CLRF   FF7
0EA8:  RLCF   FF7,F
0EAA:  ADDLW  BF
0EAC:  MOVWF  FF6
0EAE:  MOVLW  0E
0EB0:  ADDWFC FF7,F
0EB2:  TBLRD*-
0EB4:  MOVF   FF5,W
0EB6:  MOVWF  FFA
0EB8:  TBLRD*
0EBA:  MOVF   FF5,W
0EBC:  MOVWF  FF9
0EBE:  DATA 74,0D
0EC0:  DATA B4,0D
0EC2:  DATA CC,0D
0EC4:  DATA E2,0D
*
0F36:  DATA 0D,0A
0F38:  DATA 0A,55
0F3A:  DATA 53,42
0F3C:  DATA 20,63
0F3E:  DATA 6F,6E
0F40:  DATA 6E,65
0F42:  DATA 63,74
0F44:  DATA 65,64
0F46:  DATA 2C,20
0F48:  DATA 77,61
0F4A:  DATA 69,74
0F4C:  DATA 69,6E
0F4E:  DATA 67,20
0F50:  DATA 66,6F
0F52:  DATA 72,20
0F54:  DATA 65,6E
0F56:  DATA 75,6D
0F58:  DATA 61,72
0F5A:  DATA 61,74
0F5C:  DATA 69,6F
0F5E:  DATA 6E,2E
0F60:  DATA 2E,2E
0F62:  DATA 00,00
0F64:  DATA 0D,0A
0F66:  DATA 0A,55
0F68:  DATA 53,42
0F6A:  DATA 20,64
0F6C:  DATA 69,73
0F6E:  DATA 63,6F
0F70:  DATA 6E,6E
0F72:  DATA 65,63
0F74:  DATA 74,65
0F76:  DATA 64,2C
0F78:  DATA 20,77
0F7A:  DATA 61,69
0F7C:  DATA 74,69
0F7E:  DATA 6E,67
0F80:  DATA 20,66
0F82:  DATA 6F,72
0F84:  DATA 20,63
0F86:  DATA 6F,6E
0F88:  DATA 6E,65
0F8A:  DATA 63,74
0F8C:  DATA 69,6F
0F8E:  DATA 6E,2E
0F90:  DATA 2E,2E
0F92:  DATA 00,00
0F94:  DATA 0D,0A
0F96:  DATA 0A,55
0F98:  DATA 53,42
0F9A:  DATA 20,65
0F9C:  DATA 6E,75
0F9E:  DATA 6D,65
0FA0:  DATA 72,61
0FA2:  DATA 74,65
0FA4:  DATA 64,20
0FA6:  DATA 62,79
0FA8:  DATA 20,50
0FAA:  DATA 43,2F
0FAC:  DATA 48,4F
0FAE:  DATA 53,54
0FB0:  DATA 00,00
0FB2:  DATA 0D,0A
0FB4:  DATA 0A,55
0FB6:  DATA 53,42
0FB8:  DATA 20,75
0FBA:  DATA 6E,65
0FBC:  DATA 6E,75
0FBE:  DATA 6D,65
0FC0:  DATA 72,61
0FC2:  DATA 74,65
0FC4:  DATA 64,20
0FC6:  DATA 62,79
0FC8:  DATA 20,50
0FCA:  DATA 43,2F
0FCC:  DATA 48,4F
0FCE:  DATA 53,54
0FD0:  DATA 2C,20
0FD2:  DATA 77,61
0FD4:  DATA 69,74
0FD6:  DATA 69,6E
0FD8:  DATA 67,20
0FDA:  DATA 66,6F
0FDC:  DATA 72,20
0FDE:  DATA 65,6E
0FE0:  DATA 75,6D
0FE2:  DATA 65,72
0FE4:  DATA 61,74
0FE6:  DATA 69,6F
0FE8:  DATA 6E,2E
0FEA:  DATA 2E,2E
0FEC:  DATA 00,00
0FEE:  DATA 49,6E
0FF0:  DATA 69,74
0FF2:  DATA 20,55
0FF4:  DATA 53,42
0FF6:  DATA 20,0D
0FF8:  DATA 0A,00
0FFA:  DATA 49,6E
0FFC:  DATA 69,74
0FFE:  DATA 20,52
1000:  DATA 46,49
1002:  DATA 44,20
1004:  DATA 0D,0A
1006:  DATA 00,00
1008:  DATA 52,46
100A:  DATA 49,44
100C:  DATA 20,53
100E:  DATA 65,74
1010:  DATA 74,69
1012:  DATA 6E,67
1014:  DATA 2E,2E
1016:  DATA 2E,2E
1018:  DATA 2E,2E
101A:  DATA 0D,0A
101C:  DATA 00,00
101E:  DATA 44,61
1020:  DATA 74,61
1022:  DATA 20,52
1024:  DATA 46,49
1026:  DATA 44,3A
1028:  DATA 0D,0A
102A:  DATA 00,00
102C:  DATA 53,65
102E:  DATA 6E,64
1030:  DATA 20,64
1032:  DATA 61,74
1034:  DATA 61,0D
1036:  DATA 0A,00
1038:  TBLRD*+
103A:  MOVF   FF5,F
103C:  BZ    1058
103E:  MOVFF  FF6,57
1042:  MOVFF  FF7,58
1046:  MOVF   FF5,W
1048:  BTFSS  F9E.4
104A:  BRA    1048
104C:  MOVWF  FAD
104E:  MOVFF  57,FF6
1052:  MOVFF  58,FF7
1056:  BRA    1038
1058:  RETURN 0
*
1244:  MOVF   5D,W
1246:  CLRF   01
1248:  SUBWF  5C,W
124A:  BC    1252
124C:  MOVFF  5C,00
1250:  BRA    126A
1252:  CLRF   00
1254:  MOVLW  08
1256:  MOVWF  5E
1258:  RLCF   5C,F
125A:  RLCF   00,F
125C:  MOVF   5D,W
125E:  SUBWF  00,W
1260:  BTFSC  FD8.0
1262:  MOVWF  00
1264:  RLCF   01,F
1266:  DECFSZ 5E,F
1268:  BRA    1258
126A:  RETURN 0
*
1400:  MOVFF  FF2,0D
1404:  BCF    FF2.7
1406:  ADDWF  FE8,W
1408:  CLRF   FF7
140A:  RLCF   FF7,F
140C:  ADDLW  25
140E:  MOVWF  FF6
1410:  MOVLW  14
1412:  ADDWFC FF7,F
1414:  TBLRD*-
1416:  MOVF   FF5,W
1418:  MOVWF  FFA
141A:  TBLRD*
141C:  MOVF   FF5,W
141E:  BTFSC  0D.7
1420:  BSF    FF2.7
1422:  MOVWF  FF9
1424:  DATA 12,13
1426:  DATA 2C,13
1428:  DATA 46,13
142A:  DATA 60,13
*
14D6:  MOVF   01,W
14D8:  MOVFF  55,5C
14DC:  MOVLW  64
14DE:  MOVWF  5D
14E0:  RCALL  1244
14E2:  MOVFF  00,55
14E6:  MOVF   01,W
14E8:  MOVLW  30
14EA:  BNZ   14FA
14EC:  BTFSS  56.1
14EE:  BRA    150A
14F0:  BTFSC  56.3
14F2:  BRA    150A
14F4:  BTFSC  56.4
14F6:  MOVLW  20
14F8:  BRA    1500
14FA:  BCF    56.3
14FC:  BCF    56.4
14FE:  BSF    56.0
1500:  ADDWF  01,F
1502:  MOVF   01,W
1504:  BTFSS  F9E.4
1506:  BRA    1504
1508:  MOVWF  FAD
150A:  MOVFF  55,5C
150E:  MOVLW  0A
1510:  MOVWF  5D
1512:  RCALL  1244
1514:  MOVFF  00,55
1518:  MOVF   01,W
151A:  MOVLW  30
151C:  BNZ   152A
151E:  BTFSC  56.3
1520:  BRA    1534
1522:  BTFSS  56.0
1524:  BRA    1534
1526:  BTFSC  56.4
1528:  MOVLW  20
152A:  ADDWF  01,F
152C:  MOVF   01,W
152E:  BTFSS  F9E.4
1530:  BRA    152E
1532:  MOVWF  FAD
1534:  MOVLW  30
1536:  ADDWF  55,F
1538:  MOVF   55,W
153A:  BTFSS  F9E.4
153C:  BRA    153A
153E:  MOVWF  FAD
1540:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC=16 
.................... // include lb USB 
.................... #include <pic18_usb.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.h                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  This hardware layer      //// 
.................... //// supports the USB peripheral on the PIC18 family chips.  Current //// 
.................... //// supported families are:                                         //// 
.................... ////     PIC18F2455/2550/4455/4550                                   //// 
.................... ////     PIC18F2450/4450                                             //// 
.................... ////     PIC18F2458/2553/4458/4553                                   //// 
.................... ////     PIC18F13K50/14K50                                           //// 
.................... ////     PIC18F2xJ50/PIC18F4xJ50                                     //// 
.................... ////     PIC18F65J50/66J50/66J55/67J50/85J50/86J50/86J55/87J50       //// 
.................... ////     PIC18FxxK50                                                 //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... //// See the section labeled EXTRA USER FUNCTIONS for functions      //// 
.................... //// that are specific to only this HW peripheral that you may       //// 
.................... //// find useful to use in your application.                         //// 
.................... ////                                                                 //// 
.................... ////   *********** NOTE ABOUT 18F2450/4450 LIMITATIONS **********    //// 
.................... ////  Due to the limited USB RAM of this family, a limitation of     //// 
.................... ////  this driver is that there are only 3 endpoints (0, 1 and 2).   //// 
.................... ////  The HW actually supports more endpoints, but to simplify       //// 
.................... ////  driver development this driver will only support the first 3   //// 
.................... ////  so there is an easier memory block to work with.               //// 
.................... ////                                                                 //// 
.................... ////  USB_MAX_EP0_PACKET_LENGTH will also be set to 8 regardless     //// 
.................... ////  of USB speed, to save RAM.                                     //// 
.................... ////                                                                 //// 
.................... ////   ************** NOTE ABOUT HW REQUIREMENTS ****************    //// 
.................... ////  If you are not using internal pullups, you will need to put    //// 
.................... ////  an internal pullup resistor on D+ or D+ depending on if you    //// 
.................... ////  want to use slow speed or full speed.  This code configures    //// 
.................... ////  the device to use internal pullups, see usb_init() if you      //// 
.................... ////  want to change that.                                           //// 
.................... ////                                                                 //// 
.................... ////  You need approximately 470nF cap on Vusb, even if you are      //// 
.................... ////  using the internal 3.3V USB regulator.                         //// 
.................... ////                                                                 //// 
.................... ////  To run at full speed, you must use the oscillator              //// 
.................... ////  configuration (PLLx) to set the PLL divide to 4MHz.  You can   //// 
.................... ////  configure the MCU clock to any speed (up to 48MHz) but the     //// 
.................... ////  PLL must run at 4Mhz to provide the USB peripheral with a      //// 
.................... ////  96MHz clock.  See the datasheet for details.                   //// 
.................... ////                                                                 //// 
.................... ////  To run at slow speed you must configure your MCU to run at     //// 
.................... ////  24Mhz.  See the datasheet for details.                         //// 
.................... ////                                                                 //// 
.................... ////   ****************  NOTE ABOUT INTERRUPTS  ******************   //// 
.................... //// This driver uses INT_USB.  It requires INT_USB to interrupt the //// 
.................... //// PIC when an event has happened on the USB Bus.  Therfore        //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USB interrupt flag instead of relying on an         //// 
.................... //// interrupt.                                                      //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_H__ 
.................... #DEFINE __PIC18_USB_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... //let the USB Stack know that we are using a PIC with internal USB peripheral 
.................... #DEFINE __PIC__   1 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................  #define USB_USE_FULL_SPEED   1 
.................... #endif 
....................  
.................... #ifndef USB_MAX_EP0_PACKET_LENGTH 
.................... #if ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450") || (getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................    //due to limited ram, force max packet length to 8 for this chip 
....................    #define USB_MAX_EP0_PACKET_LENGTH   8 
.................... #else 
....................    #if USB_USE_FULL_SPEED==0 
....................       //slow speed requires 8byte max packet size for endpoint 0 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   8 
....................    #else 
....................       //for full speed you can still use 8bytes, but 64 will be faster 
....................       #DEFINE USB_MAX_EP0_PACKET_LENGTH   64 
....................    #endif 
.................... #endif 
.................... #endif 
....................  
.................... #if (!USB_USE_FULL_SPEED && (USB_MAX_EP0_PACKET_LENGTH!=8)) 
....................  #error Slow speed devices must use a max packet size of 8 for endpoint 0! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH < 8 
....................  #error Max Endpoint 0 length can't be less than 8! 
.................... #endif 
....................  
.................... #if USB_MAX_EP0_PACKET_LENGTH > 64 
....................  #error Max Endpoint 0 length can't be greater than 64! 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_flush_in() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for transfer 
.................... /*        len - length of data that is being tramsferred 
.................... /*        tgl - Data toggle synchronization for this packet 
.................... /* 
.................... /* Output: TRUE if success, FALSE if error (we don't control the endpoint) 
.................... /* 
.................... /* Summary: Marks the endpoint ready for transmission.  You must 
.................... /*          have already loaded the endpoint buffer with data. 
.................... /*          (IN is PIC -> PC). 
.................... /*          This routine is useful if you want to setup an endpoint by 
.................... /*          writing to the buffer directly. 
.................... /*          This routine is not necessary if you use usb_put_packet(). 
.................... /***************************************************************/ 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_flush_out() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark for release 
.................... /*        tgl - Data toggle synchronization to expect in the next packet 
.................... /* 
.................... /* Output: NONE 
.................... /* 
.................... /* Summary: Clears the previously received packet, and then marks this 
.................... /*          endpoint's receive buffer as ready for more data. 
.................... /*          (OUT is PC -> PIC).  This routine is useful if you do not 
.................... /*          want to use usb_get_packet(), instead you want to handle with 
.................... /*          the endpoint buffer directly.  Also see usb_rx_packet_size(). 
.................... /*          This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl); 
....................  
.................... /************************************************************** 
.................... /* usb_rx_packet_size() 
.................... /* 
.................... /* Input: endpoint - which endpoint to mark to check 
.................... /* 
.................... /* Output: Returns the number of bytes in the endpoint's receive buffer. 
.................... /* 
.................... /* Summary: Read the number of data stored in the receive buffer.  When you 
.................... /*    have handled the data, use usb_flush_out() to clear the buffer.  The 
.................... /*    result may be invalid if usb_kbhit() returns false for this endpoint. 
.................... /*    This routine is not necessary if you use usb_get_packet(). 
.................... /***************************************************************/ 
.................... int16 usb_rx_packet_size(int8 endpoint); 
....................  
.................... #ENDIF 
....................  
.................... #include <usb_desc_hid.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ///                          usb_desc_hid.h                            //// 
.................... ////                                                                   //// 
.................... //// An example set of device / configuration descriptors for use with //// 
.................... //// CCS's HID Demo example (see ex_usb_hid.c)                         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////   PIC18Fxx5x initial release                                      //// 
.................... ////                                                                   //// 
.................... //// March 21st, 2005:                                                 //// 
.................... ////   EP 0x01 and EP 0x81 now use USB_EP1_TX_SIZE and USB_EP1_RX_SIZE //// 
.................... ////      to define max packet size, to make it easier for dynamically //// 
.................... ////      changed code.                                                //// 
.................... ////   EP 0x01 and EP 0x81 will now use 1ms polling interval if using  //// 
.................... ////      a full speed device.                                         //// 
.................... ////                                                                   //// 
.................... //// May 4th, 2004: Optimization and cleanup.                          //// 
.................... ////                Some definitions may have changed.                 //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed non-HID descriptors pointing to faulty       //// 
.................... ////                strings                                            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
.................... #DEFINE __USB_DESCRIPTORS__ 
....................  
.................... #ifndef USB_CONFIG_PID 
....................    #define USB_CONFIG_PID  0x0020 
.................... #endif 
....................  
.................... #ifndef USB_CONFIG_VID 
....................    #define  USB_CONFIG_VID 0x0461 
.................... #endif 
....................  
.................... #ifndef USB_CONFIG_BUS_POWER 
....................    //valid range is 0..500 
....................    #define  USB_CONFIG_BUS_POWER 100   //100mA 
.................... #endif 
....................  
.................... #ifndef USB_CONFIG_VERSION 
....................    //version number that is stored into descriptor, in bcd. 
....................    //range is 00.00 to 99.99 
....................    #define  USB_CONFIG_VERSION   0x0100      //01.00 
.................... #endif 
....................  
.................... #ifndef USB_CONFIG_HID_TX_SIZE 
....................    //valid range is 0-255 
....................    #define USB_CONFIG_HID_TX_SIZE   2     //compatible with hiddemo.exe 
.................... #endif 
....................  
.................... #ifndef USB_CONFIG_HID_RX_SIZE 
....................    //valid range is 0-255 
....................    #define USB_CONFIG_HID_RX_SIZE   2     //compatible with hiddemo.exe 
.................... #endif 
....................  
.................... #ifndef USB_CONFIG_HID_TX_POLL 
....................    // for full speed devices, valid range is 1-255 
....................    // for slow speed devices, valid range is 10-255 
....................    #define USB_CONFIG_HID_TX_POLL   10 
.................... #endif 
....................  
.................... #ifndef USB_CONFIG_HID_RX_POLL 
....................    // for full speed devices, valid range is 1-255 
....................    // for slow speed devices, valid range is 10-255 
....................    #define USB_CONFIG_HID_RX_POLL   10 
.................... #endif 
....................  
.................... //Tells the CCS PIC USB firmware to include HID handling code. 
.................... #ifdef USB_HID_DEVICE 
.................... #undef USB_HID_DEVICE 
.................... #endif 
....................  
.................... #DEFINE USB_HID_DEVICE  TRUE 
....................  
.................... //the following defines needed for the CCS USB PIC driver to enable the TX endpoint 1 
.................... // and allocate buffer space on the peripheral 
.................... #ifdef USB_EP1_TX_ENABLE 
.................... #undef USB_EP1_TX_ENABLE 
.................... #endif 
.................... #define USB_EP1_TX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP1 for IN bulk/interrupt transfers 
....................  
.................... #define USB_HID_ENDPOINT   1 
....................  
.................... #ifndef USB_EP1_TX_SIZE 
....................  #if (USB_CONFIG_HID_TX_SIZE >= 64) 
....................    // interrupt endpoint max packet size is 64. 
....................    #define USB_EP1_TX_SIZE    64 
....................  #else 
....................    // by making EP packet size larger than message size, we can send message in one packet. 
....................    #define USB_EP1_TX_SIZE    (USB_CONFIG_HID_TX_SIZE+1) 
....................  #endif 
.................... #endif 
....................  
.................... #ifdef USB_EP1_RX_ENABLE 
.................... #undef USB_EP1_RX_ENABLE 
.................... #endif 
.................... #define USB_EP1_RX_ENABLE  USB_ENABLE_INTERRUPT   //turn on EP1 for OUT bulk/interrupt transfers 
....................  
.................... #ifndef USB_EP1_RX_SIZE 
....................  #if (USB_CONFIG_HID_RX_SIZE >= 64) 
....................    // interrupt endpoint max packet size is 64. 
....................    #define USB_EP1_RX_SIZE    64 
....................  #else 
....................    // by making EP packet size larger than message size, we can send message in one packet. 
....................    #define USB_EP1_RX_SIZE    (USB_CONFIG_HID_RX_SIZE+1) 
....................  #endif 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
....................    ////////////////////////////////////////////////////////////////// 
....................    /// 
....................    ///  HID Report.  Tells HID driver how to handle and deal with 
....................    ///  received data.  HID Reports can be extremely complex, 
....................    ///  see HID specifcation for help on writing your own. 
....................    /// 
....................    ///  CCS example uses a vendor specified usage, that sends and 
....................    ///  receives 2 absolute bytes ranging from 0 to 0xFF. 
....................    /// 
....................    ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_CLASS_SPECIFIC_DESC[] =  
....................    { 
....................       6, 0, 255,        // Usage Page = Vendor Defined 
....................       9, 1,             // Usage = IO device 
....................       0xa1, 1,          // Collection = Application 
....................       0x19, 1,          // Usage minimum 
....................       0x29, 8,          // Usage maximum 
....................  
....................       0x15, 0x80,       // Logical minimum (-128) 
....................       0x25, 0x7F,       // Logical maximum (127) 
....................  
....................       0x75, 8,          // Report size = 8 (bits) 
....................       0x95, USB_CONFIG_HID_TX_SIZE,        // Report count = 16 bits (2 bytes) 
....................       0x81, 2,          // Input (Data, Var, Abs) 
....................       0x19, 1,          // Usage minimum 
....................       0x29, 8,          // Usage maximum 
....................       0x75, 8,          // Report size = 8 (bits) 
....................       0x95, USB_CONFIG_HID_RX_SIZE,        // Report count = 16 bits (2 bytes) 
....................       0x91, 2,          // Output (Data, Var, Abs) 
....................       0xc0              // End Collection 
....................    }; 
....................  
....................    //if a class has an extra descriptor not part of the config descriptor, 
....................    // this lookup table defines where to look for it in the const 
....................    // USB_CLASS_SPECIFIC_DESC[] array. 
....................    //first element is the config number (if your device has more than one config) 
....................    //second element is which interface number 
....................    //set element to 0xFFFF if this config/interface combo doesn't exist 
....................    const int8 USB_CLASS_SPECIFIC_DESC_LOOKUP[USB_NUM_CONFIGURATIONS][1] = 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          0 
....................    }; 
....................  
....................    //if a class has an extra descriptor not part of the config descriptor, 
....................    // this lookup table defines the size of that descriptor. 
....................    //first element is the config number (if your device has more than one config) 
....................    //second element is which interface number 
....................    //set element to 0xFFFF if this config/interface combo doesn't exist 
....................    const int8 USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[USB_NUM_CONFIGURATIONS][1] = 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          32 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start config descriptor 
.................... ///   right now we only support one configuration descriptor. 
.................... ///   the config, interface, class, and endpoint goes into this array. 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    #DEFINE USB_TOTAL_CONFIG_LEN      41  //config+interface+class+endpoint+endpoint (2 endpoints) 
....................  
....................    const char USB_CONFIG_DESC[] = { 
....................    //IN ORDER TO COMPLY WITH WINDOWS HOSTS, THE ORDER OF THIS ARRAY MUST BE: 
....................       //    config(s) 
....................       //    interface(s) 
....................       //    class(es) 
....................       //    endpoint(s) 
....................  
....................    //config_descriptor for config index 1 
....................          USB_DESC_CONFIG_LEN, //length of descriptor size          ==1 
....................          USB_DESC_CONFIG_TYPE, //constant CONFIGURATION (CONFIGURATION 0x02)     ==2 
....................          USB_TOTAL_CONFIG_LEN,0, //size of all data returned for this config      ==3,4 
....................          1, //number of interfaces this device supports       ==5 
....................          0x01, //identifier for this configuration.  (IF we had more than one configurations)      ==6 
....................          0x00, //index of string descriptor for this configuration      ==7 
....................         #if USB_CONFIG_BUS_POWER 
....................          0x80, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==8 
....................         #else 
....................          0xC0, //bit 6=1 if self powered, bit 5=1 if supports remote wakeup (we don't), bits 0-4 unused and bit7=1         ==8 
....................         #endif 
....................          USB_CONFIG_BUS_POWER/2, //maximum bus power required (maximum milliamperes/2)  (0x32 = 100mA) 
....................  
....................    //interface descriptor 1 
....................          USB_DESC_INTERFACE_LEN, //length of descriptor      =10 
....................          USB_DESC_INTERFACE_TYPE, //constant INTERFACE (INTERFACE 0x04)       =11 
....................          0x00, //number defining this interface (IF we had more than one interface)    ==12 
....................          0x00, //alternate setting     ==13 
....................          2, //number of endpoins, except 0 (pic167xx has 3, but we dont have to use all).       ==14 
....................          0x03, //class code, 03 = HID     ==15 
....................          0x00, //subclass code //boot     ==16 
....................          0x00, //protocol code      ==17 
....................          0x00, //index of string descriptor for interface      ==18 
....................  
....................    //class descriptor 1  (HID) 
....................          USB_DESC_CLASS_LEN, //length of descriptor    ==19 
....................          USB_DESC_CLASS_TYPE, //dscriptor type (0x21 == HID)      ==20 
....................          0x00,0x01, //hid class release number (1.0)      ==21,22 
....................          0x00, //localized country code (0 = none)       ==23 
....................          0x01, //number of hid class descrptors that follow (1)      ==24 
....................          0x22, //report descriptor type (0x22 == HID)                ==25 
....................          USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][0], 0x00, //length of report descriptor            ==26,27 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==28 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==29 
....................          0x81, //endpoint number and direction (0x81 = EP1 IN)       ==30 
....................          USB_EP1_TX_ENABLE, //transfer type supported (0x03 is interrupt)         ==31 
....................          USB_EP1_TX_SIZE,0x00, //maximum packet size supported                  ==32,33 
....................          USB_CONFIG_HID_TX_POLL,  //polling interval, in ms.  (cant be smaller than 10 for slow speed)      ==34 
....................  
....................    //endpoint descriptor 
....................          USB_DESC_ENDPOINT_LEN, //length of descriptor                   ==35 
....................          USB_DESC_ENDPOINT_TYPE, //constant ENDPOINT (ENDPOINT 0x05)          ==36 
....................          0x01, //endpoint number and direction (0x01 = EP1 OUT)      ==37 
....................          USB_EP1_RX_ENABLE, //transfer type supported (0x03 is interrupt)         ==38 
....................          USB_EP1_RX_SIZE,0x00, //maximum packet size supported                  ==39,40 
....................          USB_CONFIG_HID_RX_POLL //polling interval, in ms.  (cant be smaller than 10 for slow speed)    ==41 
....................    }; 
....................  
....................    //****** BEGIN CONFIG DESCRIPTOR LOOKUP TABLES ******** 
....................    //since we can't make pointers to constants in certain pic16s, this is an offset table to find 
....................    //  a specific descriptor in the above table. 
....................  
....................    //NOTE: DO TO A LIMITATION OF THE CCS CODE, ALL HID INTERFACES MUST START AT 0 AND BE SEQUENTIAL 
....................    //      FOR EXAMPLE, IF YOU HAVE 2 HID INTERFACES THEY MUST BE INTERFACE 0 AND INTERFACE 1 
....................    #define USB_NUM_HID_INTERFACES   1 
....................  
....................    //the maximum number of interfaces seen on any config 
....................    //for example, if config 1 has 1 interface and config 2 has 2 interfaces you must define this as 2 
....................    #define USB_MAX_NUM_INTERFACES   1 
....................  
....................    //define how many interfaces there are per config.  [0] is the first config, etc. 
....................    const char USB_NUM_INTERFACES[USB_NUM_CONFIGURATIONS]={1}; 
....................  
....................    //define where to find class descriptors 
....................    //first dimension is the config number 
....................    //second dimension specifies which interface 
....................    //last dimension specifies which class in this interface to get, but most will only have 1 class per interface 
....................    //if a class descriptor is not valid, set the value to 0xFFFF 
....................    const int8 USB_CLASS_DESCRIPTORS[USB_NUM_CONFIGURATIONS][1][1]= 
....................    { 
....................    //config 1 
....................       //interface 0 
....................          //class 1 
....................          18 
....................    }; 
....................  
....................    #if (sizeof(USB_CONFIG_DESC) != USB_TOTAL_CONFIG_LEN) 
....................       #error USB_TOTAL_CONFIG_LEN not defined correctly 
....................    #endif 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start device descriptors 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
....................    const char USB_DEVICE_DESC[USB_DESC_DEVICE_LEN] ={ 
....................       //starts of with device configuration. only one possible 
....................          USB_DESC_DEVICE_LEN, //the length of this report   ==1 
....................          0x01, //the constant DEVICE (DEVICE 0x01)  ==2 
....................          0x10,0x01, //usb version in bcd ==3,4 
....................          0x00, //class code ==5 
....................          0x00, //subclass code ==6 
....................          0x00, //protocol code ==7 
....................          USB_MAX_EP0_PACKET_LENGTH, //max packet size for endpoint 0. (SLOW SPEED SPECIFIES 8) ==8 
....................          USB_CONFIG_VID & 0xFF, ((USB_CONFIG_VID >> 8) & 0xFF), //vendor id       ==9, 10 
....................          USB_CONFIG_PID & 0xFF, ((USB_CONFIG_PID >> 8) & 0xFF), //product id, don't use 0xffff       ==11, 12 
....................          USB_CONFIG_VERSION & 0xFF, ((USB_CONFIG_VERSION >> 8) & 0xFF), //device release number  ==13,14 
....................          0x01, //index of string description of manufacturer. therefore we point to string_1 array (see below)  ==15 
....................          0x02, //index of string descriptor of the product  ==16 
....................          0x00, //index of string descriptor of serial number  ==17 
....................          USB_NUM_CONFIGURATIONS  //number of possible configurations  ==18 
....................    }; 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////// 
.................... /// 
.................... ///   start string descriptors 
.................... ///   String 0 is a special language string, and must be defined.  People in U.S.A. can leave this alone. 
.................... /// 
.................... ///   You must define the length else get_next_string_character() will not see the string 
.................... ///   Current code only supports 10 strings (0 thru 9) 
.................... /// 
.................... ////////////////////////////////////////////////////////////////// 
....................  
.................... #if !defined(USB_STRINGS_OVERWRITTEN) 
.................... //the offset of the starting location of each string.  offset[0] is the start of string 0, offset[1] is the start of string 1, etc. 
.................... char USB_STRING_DESC_OFFSET[]={0,4,12}; 
....................  
.................... // Here is where the "CCS" Manufacturer string and "CCS HID Demo" are stored. 
.................... // Strings are saved as unicode. 
.................... // These strings are mostly only displayed during the add hardware wizard. 
.................... // Once the operating system drivers have been installed it will usually display 
.................... // the name from the drivers .INF. 
.................... char const USB_STRING_DESC[]={ 
....................    //string 0 
....................          4, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          0x09,0x04,   //Microsoft Defined for US-English 
....................    //string 1 
....................          8, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................    //string 2 
....................          26, //length of string index 
....................          USB_DESC_STRING_TYPE, //descriptor type 0x03 (STRING) 
....................          'C',0, 
....................          'C',0, 
....................          'S',0, 
....................          ' ',0, 
....................          'H',0, 
....................          'I',0, 
....................          'D',0, 
....................          ' ',0, 
....................          'D',0, 
....................          'e',0, 
....................          'm',0, 
....................          'o',0 
.................... }; 
.................... #endif 
....................  
.................... #ENDIF 
....................  
.................... #include <usb.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                             usb.c                                 //// 
.................... ////                                                                   //// 
.................... //// Standard USB request and token handler code.                      //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H        //// 
.................... //// for more documentation and a list of examples.                    //// 
.................... ////                                                                   //// 
.................... //// The majority of this code is called and used by the interrupt     //// 
.................... //// generated by the hardware level, and therefore it is not meant    //// 
.................... //// to be called by the user.  The functions that are meant to be     //// 
.................... //// called by the user (init, put packet, get packet, etc) are        //// 
.................... //// documented in USB.H.                                              //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////    This code will not create a multiple configuration device.     //// 
.................... ////    If you wish to create a multiple configuration device then you //// 
.................... ////    will have to modify these drivers.                             //// 
.................... ////                                                                   //// 
.................... ////   *************************  NOTE  **************************     //// 
.................... ////   This code does not support Get_Idle or Set_Idle HID-specific    //// 
.................... ////   requests.  These requests are optional.  If you want to support //// 
.................... ////   these requests you must provide the code yourself.  See         //// 
.................... ////   usb_isr_tkn_setup_ClassInterface() if you wish to add this      //// 
.................... ////   support.                                                        //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// If you wish to provide your own USB peripheral hardware layer, it //// 
.................... //// must must provide the API as described in usb_hw_layer.h.         //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// June 8th, 2011:                                                   //// 
.................... ////  Problem with usb_gets() and usb_puts() and specifying timeout=0  //// 
.................... ////     (for no timeout) resolved.                                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// November 13th, 2009:                                              //// 
.................... ////  usb_endpoint_is_valid() has an extra check.                      //// 
.................... ////                                                                   //// 
.................... //// June 9th, 2009:                                                   //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.     //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// Dec 14, 2007:                                                     //// 
.................... ////  usb_kbhit() moved to device driver.                              //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_puts() packet_size and this_packet_len changed to 16bits.    //// 
.................... ////  usb_gets() len, packet_size and this_packet_len to 16bits.       //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release.                                         //// 
.................... ////  usb_kbhit() removed, usb_kbhit() now implemented in hardware     //// 
.................... ////    layer.                                                         //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////  TODO: alot of indexing and length handling for descriptors is    //// 
.................... ////   only 8bit, so make sure all descriptor tables are less than     //// 
.................... ////   256 bytes long.                                                 //// 
.................... ////                                                                   //// 
.................... //// Apr 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_puts() doesn't need max packet size as a paremeter, uses     //// 
.................... ////   usb_ep_tx_size[] defined in usb.h                               //// 
.................... ////  usb_puts() timeout parameter now in ms, not seconds.             //// 
.................... ////  USB Stack no longer buffers incoming data.  If there is data to  //// 
.................... ////   get usb_kbhit(en) will return TRUE and the data will sit in     //// 
.................... ////   the endpoint buffer until you usb_get_packet(), which will      //// 
.................... ////   then free the endpoint buffer for more data.  This affects      //// 
.................... ////   routines such as usb_gets() and usb_kbhit().                    //// 
.................... ////  usb_gets() no longer reads buffered data (see above note),       //// 
.................... ////   now it reads multiple packets in the same way usb_puts()        //// 
.................... ////   writes multiple packets                                         //// 
.................... ////  usb_kbhit() is hardware specific, so has been moved to hardware  //// 
.................... ////   layer.                                                          //// 
.................... ////                                                                   //// 
.................... //// Nov 11th, 2004:                                                   //// 
.................... ////  No longer includes wrong descriptor header.                      //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// December 5th, 2003: Fixed a potential bug where descriptors are   //// 
.................... ////         evenly dividable by 8 (MAX_EP0_PACKET_SIZE)               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Problem with usb_puts and timeout fixed.      //// 
.................... ////                                                                   //// 
.................... //// October 28th, 2002: Typo fixed in get_next_string_character(),    //// 
.................... ////                     although it didn't cause any serious problems //// 
.................... ////                                                                   //// 
.................... //// October 25th, 2002: Another change to usb_puts() was made to fix  //// 
.................... ////                     problems with multiple packet messages        //// 
.................... //// October 29th, 2002: Fixed a problem with multiple packet string   //// 
.................... ////                     descriptors that require a 0 len packet to    //// 
.................... ////                     end message.                                  //// 
.................... ////                                                                   //// 
.................... //// October 23rd, 2002: usb_puts() will bomb out of error quicker     //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_DRIVER__ 
.................... #DEFINE __USB_DRIVER__ 
....................  
.................... #if defined(__DO_DEBUG_USB) 
....................    #define debug_usb printf 
....................    void debug_putc(char c) {uart_putc(c);} 
....................    void debug_display_ram(unsigned int8 len, unsigned int8 *ptr) { 
....................       unsigned int8 max=16; 
....................       debug_usb(debug_putc,"[%U - ",len); 
....................       //if (max>len) {max=len;} 
....................       max = len; 
....................       while(max--) { 
....................          debug_usb(debug_putc,"%02X",*ptr); 
....................          len--; 
....................          ptr++; 
....................       } 
....................       if (len) {debug_usb(debug_putc,"...");} 
....................       debug_usb(debug_putc,"] "); 
....................    } 
.................... #else 
....................    #define debug_usb(a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z) 
....................    #define debug_putc(c) 
....................    #define debug_display_ram(x,y) 
.................... #endif 
....................  
.................... #include <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #if defined(__PIC16F_USB_H__) 
....................  #include <pic16f_usb.c> 
.................... #endif 
....................  
.................... #if defined(__PIC18_USB_H__) 
....................  #include <pic18_usb.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                          pic18_usb.c                            //// 
.................... ////                                                                 //// 
.................... //// Hardware layer for CCS's USB library.  See pic18_usb.h more     //// 
.................... //// documentation about the PIC18 hardware layer.                   //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// Feb 22, 2013:                                                   //// 
.................... ////  Added support for 18F45K50 family.                             //// 
.................... ////                                                                 //// 
.................... //// July 9th, 2012:                                                 //// 
.................... ////  Removed the clearing of the UOWN bit inside token done ISR     //// 
.................... ////     for non-setup packets on endpoint 0 or all other            //// 
.................... ////     endpoints.  This really only affects people using           //// 
.................... ////     usb_put_packet() or usb_get_packet() inside of other        //// 
.................... ////     interrupts.                                                 //// 
.................... ////                                                                 //// 
.................... //// Sep 22, 2011:                                                   //// 
.................... ////  Added USB_NO_ISR_PREPROCESSOR.  This is a rarely used option   //// 
.................... ////     primarily developed for users developing code where         //// 
.................... ////     usb_isr() is called by a #int_global instead of #int_usb.   //// 
.................... ////                                                                 //// 
.................... //// Dec 16, 2010:                                                   //// 
.................... ////  PIC18LF13K50 and PIC18LF14K50 added.                           //// 
.................... ////                                                                 //// 
.................... //// Oct 15th, 2010:                                                 //// 
.................... ////  Added initial 18F47J53 family support.                         //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts     //// 
.................... ////     will not be used.  usb_task() must be called periodically   //// 
.................... ////     in your main loop.  If it is not called faster than once    //// 
.................... ////     per millisecond, USB may not work.                          //// 
.................... ////                                                                 //// 
.................... //// Nov 13th, 2009:                                                 //// 
.................... ////  usb_disable_endpoint() won't touch BD status registers for     //// 
.................... ////     endpoints that aren't allocated.                            //// 
.................... ////                                                                 //// 
.................... //// June 9th, 2009:                                                 //// 
.................... ////  Some problems with Vista and fast hubs/hosts fixed on PIC18.   //// 
.................... ////                                                                 //// 
.................... //// May 8th, 2009:                                                  //// 
.................... ////  Problems with 18F14K50 fixed.                                  //// 
.................... ////  Added 18F46J50 family.                                         //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   18F14K50 family added.                                        //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// Nov 3rd, 2008:                                                  //// 
.................... ////  * 4553 family added.                                           //// 
.................... ////                                                                 //// 
.................... //// Dec 18, 2007:                                                   //// 
.................... ////  * usb_kbhit() moved to device driver.                          //// 
.................... ////  * USB Token handler changed to workaround a flaw in the USB    //// 
.................... ////     peripheral to prevent the USB peripheral from               //// 
.................... ////     inadvertantly STALLing the endpoint.  Happened most often   //// 
.................... ////     in bulk demo applications, especially CDC.                  //// 
.................... ////                                                                 //// 
.................... ////   11-6-07:  Fixed a bug where usb_data_buffer[] was reserving   //// 
.................... ////                 too much RAM.                                   //// 
.................... ////             USB_MAX_EP0_PACKET_LENGTH value can be overwritten. ////  
.................... ////                 For the 18F4450/2450 family this should be 8    //// 
.................... ////                 because of limited RAM.  Reducing this value    ////  
.................... ////                 frees RAM for application.                      //// 
.................... ////             Based upon which endpoints have been configured for //// 
.................... ////                 use, will free up unused USB data RAM for       //// 
.................... ////                 application dynamically.  This should free up   //// 
.................... ////                 at least 128 bytes of RAM.                      //// 
.................... ////             CDC now fits on a 18F4450/2450                      //// 
.................... ////                                                                 //// 
.................... ////   09-19-07: Fixed problems with 18F4450 family.                 //// 
.................... ////                                                                 //// 
.................... ////   07-17-07: Added 18F4450,2450 support                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-07: Added 87J50 family support                          //// 
.................... ////                                                                 //// 
.................... ////   11-01-05: usb_detach(), usb_attach() and usb_init_cs()        //// 
.................... ////               changed for the better.                           //// 
.................... ////                                                                 //// 
.................... ////   10-28-05: Added usb_rx_packet_size()                          //// 
.................... ////                                                                 //// 
.................... ////   07-13-05: usb_put_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_in() changed for 16bit packet sizes       //// 
.................... ////             usb_get_packet() changed for 16bit packet sizes     //// 
.................... ////             usb_flush_out() changed for 16bit packet sizes      //// 
.................... ////             usb_set_configured() changed for 16bit packet sizes //// 
.................... ////                                                                 //// 
.................... ////   06-30-05: usb_tbe() added                                     //// 
.................... ////             The way endpoint 0 DTS is set has been changed.     //// 
.................... ////                                                                 //// 
.................... ////   06-20-05: Initial Release                                     //// 
.................... ////                                                                 //// 
.................... ////   05-13-05: Beta Release (Full Speed works)                     //// 
.................... ////                                                                 //// 
.................... ////   03-21-05: Initial Alpha Release                               //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __PIC18_USB_C__ 
.................... #DEFINE __PIC18_USB_C__ 
....................  
.................... #INCLUDE <usb.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                              usb.h                                //// 
.................... ////                                                                   //// 
.................... //// Function protypes, defintions and globals used by CCS USB driver  //// 
.................... ////                                                                   //// 
.................... //// This file is part of CCS's USB driver code                        //// 
.................... ////                                                                   //// 
.................... //// The following USB examples are provided by CCS:                   //// 
.................... ////   ex_usb_mouse.c - A HID Mouse.                                   //// 
.................... ////   ex_usb_keyboard.c - A HID Keyboard.                             //// 
.................... ////   ex_usb_hid.c - A custom application using HID protocol.         //// 
.................... ////   ex_usb_kbmouse.c - A HID Mouse/Keyboard combo using multiple    //// 
.................... ////                      interfaces.                                  //// 
.................... ////   ex_usb_kbmouse2.c - A HID Mouse/Keyboard combo using multiple   //// 
.................... ////                      HID Reports.                                 //// 
.................... ////   ex_usb_scope.c - A digital oscilloscope using a custom          //// 
.................... ////                    protocol requiring custom Windows drivers.     //// 
.................... ////   ex_usb_serial.c -                                               //// 
.................... ////   ex_usb_serial2.c - Two examples of using the CDC driver for     //// 
.................... ////     a virtual COM port.                                           //// 
.................... ////   ex_usb_bootloader.c - CDC/Virtual COM port bootloader.          //// 
.................... ////   ex_usb_loadmouse.c - A conversion of ex_usb_mouse.c that is     //// 
.................... ////        compatible with ex_usb_mouse.c.                            //// 
.................... ////                                                                   //// 
.................... ////        ********************** API *********************           //// 
.................... ////                                                                   //// 
.................... //// These are the functions that are meant to be called by the user:  //// 
.................... ////                                                                   //// 
.................... //// usb_init() - Initializes the USB stack, the USB peripheral and    //// 
.................... ////              attaches the unit to the usb bus.  Enables           //// 
.................... ////              interrupts.  Will wait in an infinite loop until     //// 
.................... ////              the device enumerates - if you are using             //// 
.................... ////              connection sense or if the processor should run      //// 
.................... ////              even if it's not connected to USB then use           //// 
.................... ////              usb_init_cs() instead.                               //// 
.................... ////                                                                   //// 
.................... //// usb_init_cs() - A smaller usb_init(), does not attach unit        //// 
.................... ////              to usb bus or enable interrupts.  Since this does    //// 
.................... ////              not attach to the USB, you must periodically call    //// 
.................... ////              usb_task().  See usb_task() for more information.    //// 
.................... ////                                                                   //// 
.................... //// usb_task() - If usb_init_cs() was used to initiate the USB        //// 
.................... ////        peripheral, usb_task() should then be called periodically  //// 
.................... ////        to check the connection sense pin.  If the connection      //// 
.................... ////        sense pin denotes USB is connected and the USB peripheral  //// 
.................... ////        is not attached, this will attach the USB peripheral       //// 
.................... ////        so the PC can start the enumeration process (and it        //// 
.................... ////        will enable interrupts).  If the connection sense pin      //// 
.................... ////        denotes USB is not attached and the USB peripheral is      //// 
.................... ////        running, this will reset the USB peripheral and wait       //// 
.................... ////        for USB to reconnect (and usb_enumerated() will start      //// 
.................... ////        returning FALSE).  If connection sense macro               //// 
.................... ////        (USB_CABLE_IS_ATTACHED) is not defined the usb_task()      ////  
.................... ////        assumes that USB is always connected.                      //// 
.................... ////                                                                   //// 
.................... //// usb_attached() - Returns TRUE if the device is attached to a      //// 
.................... ////                  USB cable.  A macro that looks at the defined    //// 
.................... ////                  connection sense pin.  If this returns TRUE      //// 
.................... ////                  it does not mean the PC has connected to it,     //// 
.................... ////                  you need to use usb_enumerated() to check this.  //// 
.................... ////                                                                   //// 
.................... //// usb_enumerated() - Returns TRUE if device has been enumerated     //// 
.................... ////                    (configured) by host, FALSE if it has not.     //// 
.................... ////                    Do not try to use the USB peripheral for       //// 
.................... ////                    sending and receiving packets until you        //// 
.................... ////                    are enumerated.                                //// 
.................... ////                                                                   //// 
.................... //// usb_wait_for_enumeration() - Sits in an infinte loop until device //// 
.................... ////                              is enumerated.                       //// 
.................... ////                                                                   //// 
.................... //// usb_tbe(endpoint) - Returns TRUE if the endpoint transmit buffer  //// 
.................... ////     is free and ready to accept a new packet for transmission.    //// 
.................... ////                                                                   //// 
.................... //// usb_put_packet(endpoint, ptr, len, tgl) - Sends one packet to the //// 
.................... ////                    host.  If you need to send a message that      //// 
.................... ////                    spans more than one packet then use            //// 
.................... ////                    usb_puts().  Fore more detailed documentation  //// 
.................... ////                    see usb_hw_layer.h                             //// 
.................... ////                                                                   //// 
.................... //// usb_puts(endpoint, ptr, len, timeout) - Sends a multiple packet   //// 
.................... ////     message to the host.  If you only need to send one packet,    //// 
.................... ////     it is more effecient to use usb_put_packet().  This is        //// 
.................... ////     documented in more detail above the prototype in USB.H.       //// 
.................... ////                                                                   //// 
.................... //// usb_kbhit(endpoint) - Returns true if OUT endpoint contains data  //// 
.................... ////               from host.  This will remain TRUE until             //// 
.................... ////               usb_put_packet() or usb_flush_out() used.           //// 
.................... ////               This function will return an invalid response       //// 
.................... ////               if specified endpoint is not enabled for            //// 
.................... ////               receiving data.                                     //// 
.................... ////                                                                   //// 
.................... //// len = usb_get_packet(endpoint, ptr, max) - Gets one packet that   //// 
.................... ////        from the host/PC.  usb_kbhit() must return TRUE before you //// 
.................... ////        call this routine or your data may not be valid.  This     //// 
.................... ////        only receives one packet, if you are trying to receive a   ////  
.................... ////        multi-packet message use usb_gets().  For more detailed    //// 
.................... ////        documentation see usb_hw_layer.h.                          //// 
.................... ////                                                                   //// 
.................... //// len = usb_gets(endpoint, ptr, max, timeout) - Gets multiple       //// 
.................... ////        packets from the host, you would use this instead          //// 
.................... ////        of usb_get_packet() if you wanted to handle multi-packet   //// 
.................... ////        messages.  This is documented in more detail above the     //// 
.................... ////        prototype in USB.H.                                        //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... ////        ********* DEFINITIONS / CONFIGURATION **********           //// 
.................... ////                                                                   //// 
.................... //// The following definitions are declared here, but can be           //// 
.................... //// overwritten in your code.  Unless needed otherwise, leave         //// 
.................... //// to default value.  If confused about a definition read the        //// 
.................... //// comments at each defintion                                        //// 
.................... ////                                                                   //// 
.................... //// USB_HID_IDLE (TRUE) - Set to TRUE if your device supports         //// 
.................... ////                            Set_Idle HID class request.  Set to    //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Idle / Get_Idle command)   //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code.  See            //// 
.................... ////                            usb_isr_tkn_setup_ClassInterface() in  //// 
.................... ////                            usb.c                                  //// 
.................... ////                                                                   //// 
.................... //// USB_HID_BOOT_PROTOCOL (FALSE) - Set to TRUE if your device supports   //// 
.................... ////                            Set_Protocl HID class request. Set to  //// 
.................... ////                            False if you do not (device will       //// 
.................... ////                            send a Wrong-state if computer         //// 
.................... ////                            sends a Set_Protocl / Get_Protocol     //// 
.................... ////                            command).                              //// 
.................... ////                            NOTE: If you set to TRUE you must      //// 
.................... ////                            provide your own code in the           //// 
.................... ////                            application that properly send boot    //// 
.................... ////                            or HID packets.                        //// 
.................... ////                                                                   //// 
.................... //// USB_MAX_EP0_PACKET_LENGTH (8) - Max Packet size for Endpoint 0.   //// 
.................... ////                            The hardware level driver (ex          //// 
.................... ////                            pic18_usb.h will define this value if  //// 
.................... ////                            not already overwritten).  Increasing  //// 
.................... ////                            this size will speed up the            //// 
.................... ////                            enumeration process.                   //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this RX (PC to device) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_RX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for receiving    //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_RX_ENABLE defined and    //// 
.................... ////               USB_EPx_RX_SIZE defined (non 0) to enable a RX      //// 
.................... ////               endpoint.                                           //// 
.................... ////  *** NOTE *** Endpoint 0 is always enabled.                       //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_ENABLE (USB_ENABLE_DISABLED) - Where x is the          //// 
.................... ////                         endpoint number. Change this define       //// 
.................... ////                         to specify what kind of transfer method   //// 
.................... ////                         this TX (device to PC) endpoint uses.     //// 
.................... ////                       Here is the list of valid transfer methods: //// 
.................... ////                             USB_ENABLE_CONTROL                    //// 
.................... ////                             USB_ENABLE_ISOCHRONOUS                //// 
.................... ////                             USB_ENABLE_BULK                       //// 
.................... ////                             USB_ENABLE_INTERRUPT                  //// 
.................... ////                             USB_ENABLE_DISABLED                   //// 
.................... ////                        Don't forget that you must specify the     //// 
.................... ////                        transfer method properly in your endpoint  //// 
.................... ////                        descriptor, too.                           //// 
.................... ////                                                                   //// 
.................... //// USB_EPx_TX_SIZE (0) - For some hardware it is important to know   //// 
.................... ////                       how much memory to reserve for transmitting //// 
.................... ////                       packets.                                    //// 
.................... ////                                                                   //// 
.................... ////  *** NOTE *** You must have both USB_EPx_TX_ENABLE defined and    //// 
.................... ////               USB_EPx_TX_SIZE defined (non 0) to enable a TX      //// 
.................... ////               endpoint.                                           //// 
.................... ////                                                                   //// 
.................... ////                                                                   //// 
.................... //// USB_HID_DEVICE (TRUE) - HID devices require extra code to handle  //// 
.................... ////                         HID requests.  You can disable to save    //// 
.................... ////                         ROM space if you are not using a HID      //// 
.................... ////                         device.  If you are not using a HID       //// 
.................... ////                         device you must provide your own O/S      //// 
.................... ////                         (Windows) driver.                         //// 
.................... ////                                                                   //// 
.................... //// The other definitions should not be changed.                      //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... ////  Feb 18th, 2013                                                   //// 
.................... ////     Added some extra checks to make sure packet size are legal    //// 
.................... ////        for USB speed.                                             //// 
.................... ////                                                                   //// 
.................... ////  April 2nd, 2012                                                  //// 
.................... ////     Initial version of CDC+HID composite device support           //// 
.................... ////                                                                   //// 
.................... //// Oct 15th, 2010:                                                   //// 
.................... ////  Potential bug in CDC that causes lost PIC->PC chars resolved?    //// 
.................... ////  Added initial 18F47J53 family support.                           //// 
.................... ////  Added USB_ISR_POLLING support.  Define this and interrupts       //// 
.................... ////     will not be used.  usb_task() must be called periodically     //// 
.................... ////     in your main loop.  If it is not called faster than once      //// 
.................... ////     per millisecond, USB may not work (PIC18 and PIC24 only).     //// 
.................... ////                                                                   //// 
.................... //// September 24th, 2010:                                             //// 
.................... ////  Many descriptor files had the self powered bit set incorrectly   //// 
.................... ////     based on USB_CONFIG_BUS_POWER.                                //// 
.................... ////                                                                   //// 
.................... //// September 9th, 2010:                                              //// 
.................... ////  USB_CONFIG_HID_TX_SIZE and USB_CONFIG_HID_RX_SIZE were backwards //// 
.................... ////     in HID report descriptor of usb_desc_hid.h                    //// 
.................... ////                                                                   //// 
.................... //// September 2nd, 2010:                                              //// 
.................... ////  Problem with descriptors larger than 127 bytes on 16-bit PICs    //// 
.................... ////     (dsPIC, PIC24) resolved.                                      //// 
.................... ////                                                                   //// 
.................... //// August 31st, 2010:                                                //// 
.................... ////  Added USB_HW_MCHP_18F46J50, USB_HW_MCHP_18F14K50 and             //// 
.................... ////  USB_HW_GENERIC_18F67J50 hardware.                                //// 
.................... ////                                                                   //// 
.................... //// April 28th, 2010:                                                 //// 
.................... ////  USB_CON_SENSE_PIN replaced with USB_CABLE_IS_ATTACHED()          //// 
.................... ////     macro.  If USB_CON_SENSE_PIN is defined, it will create       //// 
.................... ////     USB_CABLE_IS_ATTACHED() macro for you (for backwards          //// 
.................... ////     compatibility).                                               //// 
.................... ////                                                                   //// 
.................... //// Nov 13th, 2009:                                                   //// 
.................... ////  usb_endpoint_is_valid() prototyped.                              //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... //// July 13th, 2005:                                                  //// 
.................... ////  usb_ep_tx_size[] and usb_ep_rx_size[] changed to 16bits          //// 
.................... ////                                                                   //// 
.................... //// June 20th, 2005:                                                  //// 
.................... ////  Initial 18fxx5x release                                          //// 
.................... ////                                                                   //// 
.................... //// May 13th, 2005:                                                   //// 
.................... ////  Beta release, only works with 18Fxx5x hardware layer.            //// 
.................... ////  Now supports multiple interfaces (many defines in descriptors    //// 
.................... ////   will have to be changed, see examples)                          //// 
.................... ////                                                                   //// 
.................... //// Mar 21st, 2005:                                                   //// 
.................... ////  Initial Alpha Release with PIC18Fxx5x support.  (ONLY TESTED     //// 
.................... ////   WITH 18F4550)                                                   //// 
.................... ////  usb_gets() and usb_puts() changed (see usb.c)                    //// 
.................... ////                                                                   //// 
.................... //// June 24th, 2004:                                                  //// 
.................... ////  Optimization and cleanup.                                        //// 
.................... ////                The following definitions changed:                 //// 
.................... ////  USB_EPx_TX_ENABLE and USB_EPx_RX_ENABLE have changed. See usb.h  //// 
.................... ////  USB_CONFIG_DESCRIPTORS[] removed                                 //// 
.................... ////  USB_CONFIG_DESC_LEN changed to USB_DESC_CONFIG_LEN               //// 
.................... ////  USB_INTERFACE_DESC_LEN changed to USB_DESC_INTERFACE_LEN         //// 
.................... ////  USB_CLASS_DESC_LEN changed to USB_DESC_CLASS_LEN                 //// 
.................... ////  USB_ENDPOINT_DESC_LEN changed to USB_DESC_ENDPOINT_LEN           //// 
.................... ////  USB_CONFIG_DESC_KEY changed to USB_DESC_CONFIG_TYPE              //// 
.................... ////  USB_INTERFACE_DESC_KEY changed to USB_DESC_INTERFACE_TYPE        //// 
.................... ////  USB_CLASS_DESC_KEY changed to USB_DESC_CLASS_TYPE                //// 
.................... ////  USB_ENDPOINT_DESC_KEY changed to USB_DESC_ENDPOINT_TYPE          //// 
.................... ////  USB_STRING_X[] arrays removed, see USB_STRING_DESC[] and         //// 
.................... ////                                 USB_STRING_DESC_OFFSET[]          //// 
.................... ////  dev_req, curr_config, status_device and getdesc_type global      //// 
.................... ////        variables moved into struct USB_stack_status               //// 
.................... ////                                                                   //// 
.................... //// October 15th, 2003: Support for boot protocol added.              //// 
.................... ////         Set USB_HID_BOOT_PROTOCOL to TRUE to support this.        //// 
.................... ////         The array hid_protocol[] saves which protocol mode each   //// 
.................... ////         interface is in.  It is your applications job to send     //// 
.................... ////         data that either fit the boot protocol or HID protocol.   //// 
.................... ////                                                                   //// 
.................... //// May 6th, 2003: Fixed a potential stack overflow using PCM         //// 
.................... ////                                                                   //// 
.................... //// October 29th, 2002: New definition added to USB_STATES            //// 
.................... ////                                                                   //// 
.................... //// August 2nd, 2002: Initial Public Release                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USB_PROTOTYPES__ 
.................... #DEFINE __USB_PROTOTYPES__ 
....................  
.................... //// CONFIGURATION //////////////////////////////////////////////////////////// 
....................  
.................... #if defined(USB_CON_SENSE_PIN) 
....................  #undef USB_CABLE_IS_ATTACHED 
....................  #define USB_CABLE_IS_ATTACHED() input(USB_CON_SENSE_PIN) 
.................... #endif 
....................  
.................... #IFNDEF USB_HID_BOOT_PROTOCOL 
....................    #DEFINE USB_HID_BOOT_PROTOCOL FALSE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_HID_IDLE 
....................    #DEFINE USB_HID_IDLE FALSE 
.................... #ENDIF 
....................  
.................... //should the compiler add the extra HID handler code?  Defaults to yes. 
.................... #IFNDEF USB_HID_DEVICE 
....................    #DEFINE USB_HID_DEVICE TRUE 
.................... #ENDIF 
....................  
.................... #IFNDEF USB_CDC_DEVICE 
....................    #DEFINE USB_CDC_DEVICE FALSE 
.................... #ENDIF 
....................  
.................... //set to false to opt for less RAM, true to opt for less ROM 
.................... #ifndef USB_OPT_FOR_ROM 
....................    #define USB_OPT_FOR_ROM TRUE 
.................... #endif 
....................  
.................... #IFNDEF USB_MAX_EP0_PACKET_LENGTH 
....................   #DEFINE USB_MAX_EP0_PACKET_LENGTH 8 
.................... #ENDIF 
....................  
....................  
.................... ////// USER-LEVEL API ///////////////////////////////////////////////////////// 
....................  
.................... /************************************************************** 
.................... /* usb_enumerated() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* Returns: Returns a 1 if device is configured / enumerated, 
.................... /*          Returns a 0 if device is un-configured / not enumerated. 
.................... /* 
.................... /* Summary: See API section of USB.H for more documentation. 
.................... /***************************************************************/ 
.................... int1 usb_enumerated(void); 
....................  
.................... /************************************************************** 
.................... /* usb_wait_for_enumeration() 
.................... /* 
.................... /* Input: Global variable USB_Curr_Config 
.................... /* 
.................... /* Summary: Waits in-definately until device is configured / enumerated. 
.................... /*          See API section of USB.H for more information. 
.................... /***************************************************************/ 
.................... void usb_wait_for_enumeration(void); 
....................  
.................... /**************************************************************************** 
.................... /* usb_gets(endpoint, ptr, max, timeout) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - place / array to store data to 
.................... /*        max - max amount of data to get from USB and store into ptr 
.................... /*         timeout - time in milliseconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Output: Amount of data returned.  It may be less than max. 
.................... /* 
.................... /* Summary: Gets data from the host.  Will get multiple-packet messages 
.................... /*          and finish when either it receives a 0-len packet or a packet 
.................... /*          of less size than maximum. 
.................... /* 
.................... /*****************************************************************************/ 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout); 
....................  
.................... /**************************************************************************** 
.................... /* usb_puts() 
.................... /* 
.................... /* Inputs: endpoint - endpoint to send data out 
.................... /*         ptr - points to array of data to send 
.................... /*         len - amount of data to send 
.................... /*         timeout - time in milli-seconds, for each packet, to wait before  
.................... /*                   timeout.  set to 0 for no timeout. 
.................... /* 
.................... /* Outputs: Returns TRUE if message sent succesfully, FALSE if it was not 
.................... /*    sent before timeout period expired. 
.................... /* 
.................... /* Summary: Used for sending multiple packets of data as one message.  This 
.................... /*       function can still be used to send messages consiting of only one  
.................... /*       packet.  See usb_put_packet() documentation for the rules about when  
.................... /*       multiple packet messages or 0-lenght packets are needed. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attached() 
.................... /* 
.................... /* Summary: Returns TRUE if the device is attached to a USB cable. 
.................... /*          See the API section of USB.H for more documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... #if defined(USB_CABLE_IS_ATTACHED) 
....................  #define usb_attached() USB_CABLE_IS_ATTACHED() 
.................... #else 
....................  #define usb_attached() TRUE 
.................... #endif 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint); 
....................  
....................  
.................... ////// END USER-LEVEL API ///////////////////////////////////////////////////// 
....................  
....................  
.................... ////// STACK-LEVEL API USED BY HW DRIVERS //////////////////////////////////// 
....................  
.................... enum USB_STATES {GET_DESCRIPTOR=1,SET_ADDRESS=2,NONE=0}; 
....................  
.................... enum USB_GETDESC_TYPES {USB_GETDESC_CONFIG_TYPE=0,USB_GETDESC_HIDREPORT_TYPE=1,USB_GETDESC_STRING_TYPE=2,USB_GETDESC_DEVICE_TYPE=3}; 
....................  
.................... #if USB_OPT_FOR_ROM 
.................... typedef struct { 
....................    USB_STATES dev_req;   //what did the last setup token set us up to do?.  init at none 
....................    int  curr_config;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #else 
.................... typedef struct { 
....................    USB_STATES dev_req:2;   //what did the last setup token set us up to do?.  init at none 
....................    int  Curr_config:2;  //our current config.  start at none/powered (NOT THAT THIS LIMITS US TO 3 CONFIGURATIONS) 
....................    int status_device:2; //Holds our state for Set_Feature and Clear_Feature 
....................    USB_GETDESC_TYPES getdesc_type:2;   //which get_descriptor() we are handling 
.................... } TYPE_USB_STACK_STATUS; 
.................... #endif 
....................  
.................... extern TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... /************************************************************** 
.................... /* usb_token_reset() 
.................... /* 
.................... /* Output:  No output (but many global registers are modified) 
.................... /* 
.................... /* Summary: Resets the token handler to initial (unconfigured) state. 
.................... /***************************************************************/ 
.................... void usb_token_reset(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_setup_dne() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[] contains the the setup packet. 
.................... /* 
.................... /* Output: None (many globals are changed) 
.................... /* 
.................... /* Summary: This function is that handles the setup token. 
.................... /*          We must handle all relevant requests, such as Set_Configuration,  
.................... /*          Get_Descriptor, etc. 
.................... /* 
.................... /*  usb_ep0_rx_buffer[] contains setup data packet, which has the  
.................... /*  following records: 
.................... /*  ------------------------------------------------------------------------------------------- 
.................... /*  usb_ep0_rx_buffer[ 0 ]=bmRequestType; Where the setup packet goes 
.................... /*                              bit7   (0) host-to-device 
.................... /*                                     (1) device-to-host 
.................... /*                              bit6-5 (00) usb standard request; 
.................... /*                                     (01) class request; 
.................... /*                                     (10) vendor request 
.................... /*                                     (11) reserved 
.................... /*                              bit4-0 (0000) device 
.................... /*                                     (0001) interface 
.................... /*                                     (0010) endpoint 
.................... /*                                     (0011) other element 
.................... /*                                     (0100) to (1111) reserved 
.................... /*  usb_ep0_rx_buffer[ 1 ]=bRequest ; the request 
.................... /*  usb_ep0_rx_buffer[2,3]=wValue ; a value which corresponds to request 
.................... /*  usb_ep0_rx_buffer[4,5]=wIndex ; could correspond to interface or endpoint... 
.................... /*  usb_ep0_rx_buffer[6,7]=wLength ; number of bytes in next data packet; 
.................... /*    for host-to-device, this exactly how many bytes in data packet. 
.................... /*    for device-to-host, this is the maximum bytes that can fit one packet. 
.................... /***************************************************************/ 
.................... void usb_isr_tok_setup_dne(void); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_out_dne() 
.................... /* 
.................... /* Input: endpoint contains which endpoint we are receiving data (0..15) 
.................... /* 
.................... /* Summary: Processes out tokens (out is respective of the host, so actualy  
.................... /*          incoming to the pic), but not out setup tokens.  Normally when 
.................... /*          data is received it is left in the buffer (user would use 
.................... /*          usb_kbhit() and usb_get_packet() to receive data), but certain 
.................... /*          libraries (like CDC) have to answer setup packets. 
.................... /*           
.................... /***************************************************************/ 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint); 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tok_in_dne(endpoint) 
.................... /* 
.................... /* Input: endpoint - which endpoint we are processing a setup token. 
.................... /* 
.................... /* Summary: This handles an IN packet (HOST <- PIC).  For endpoint 0, this 
.................... /*    is usually to setup a response packet to a setup packet.  Endpoints 1..15 
.................... /*    are generally ignored, and the user has to use usb_tbe() to determine if 
.................... /*    if the buffer is ready for a new transmit packet (there are special cases, 
.................... /*    like CDC which handles the CDC protocl). 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint); 
....................  
.................... ////// END STACK-LEVEL API USED BY HW DRIVERS ///////////////////////////////// 
....................  
....................  
.................... //CCS only supports one configuration at this time 
.................... #DEFINE USB_NUM_CONFIGURATIONS 1 //DO NOT CHANGE 
....................  
.................... //PID values for tokens (see page 48 of USB Complete ed.1) 
.................... #define PID_IN       0x09  //device to host transactions 
.................... #define PID_OUT      0x01  //host to device transactions 
.................... #define PID_SETUP    0x0D  //host to device setup transaction 
.................... #define PID_ACK      0x02  //receiver accepts error-free data packet 
.................... #define PID_DATA0    0x03  //data packet with even sync bit 
.................... #define PID_SOF      0x05  //start of framer marker and frame number 
.................... #define PID_NAK      0x0A  //receiver can't accept data or sender cant send data or has no data to transmit 
.................... #define PID_DATA1    0x0B  //data packet with odd sync bit 
.................... #define PID_PRE      0x0C  //preamble issued by host.  enables downstream traffic to low-speed device 
.................... #define PID_STALL    0x0E  //a control request isnt supported or the endpoint is halted 
....................  
.................... //Key which identifies descritpors 
.................... #DEFINE USB_DESC_DEVICE_TYPE     0x01  //#DEFINE USB_DEVICE_DESC_KEY      0x01 
.................... #DEFINE USB_DESC_CONFIG_TYPE     0x02  //#DEFINE USB_CONFIG_DESC_KEY      0x02 
.................... #DEFINE USB_DESC_STRING_TYPE     0x03  //#DEFINE USB_STRING_DESC_KEY      0x03 
.................... #DEFINE USB_DESC_INTERFACE_TYPE  0x04  //#DEFINE USB_INTERFACE_DESC_KEY   0x04 
.................... #DEFINE USB_DESC_ENDPOINT_TYPE   0x05  //#DEFINE USB_ENDPOINT_DESC_KEY    0x05 
.................... #DEFINE USB_DESC_CLASS_TYPE      0x21  //#DEFINE USB_CLASS_DESC_KEY       0x21 
.................... #DEFINE USB_DESC_HIDREPORT_TYPE  0x22 
.................... #define USB_DESC_IAD_TYPE        0x0b 
....................  
.................... //The length of each descriptor 
.................... #DEFINE USB_DESC_DEVICE_LEN      18 //#DEFINE USB_DEVICE_DESC_LEN      18 
.................... #DEFINE USB_DESC_CONFIG_LEN      9  //#DEFINE USB_CONFIG_DESC_LEN      9 
.................... #DEFINE USB_DESC_INTERFACE_LEN   9  //#DEFINE USB_INTERFACE_DESC_LEN   9 
.................... #DEFINE USB_DESC_CLASS_LEN       9  //#DEFINE USB_CLASS_DESC_LEN       9 
.................... #DEFINE USB_DESC_ENDPOINT_LEN    7  //#DEFINE USB_ENDPOINT_DESC_LEN    7 
.................... #define USB_DESC_IAD_LEN         8 
....................  
.................... //Standard USB Setup bRequest Codes 
.................... #define USB_STANDARD_REQUEST_GET_STATUS         0x00 
.................... #define USB_STANDARD_REQUEST_CLEAR_FEATURE      0x01 
.................... #define USB_STANDARD_REQUEST_SET_FEATURE        0x03 
.................... #define USB_STANDARD_REQUEST_SET_ADDRESS        0x05 
.................... #define USB_STANDARD_REQUEST_GET_DESCRIPTOR     0x06 
.................... #define USB_STANDARD_REQUEST_SET_DESCRIPTOR     0x07 
.................... #define USB_STANDARD_REQUEST_GET_CONFIGURATION  0x08 
.................... #define USB_STANDARD_REQUEST_SET_CONFIGURATION  0x09 
.................... #define USB_STANDARD_REQUEST_GET_INTERFACE      0x0A 
.................... #define USB_STANDARD_REQUEST_SET_INTERFACE      0x0B 
.................... #define USB_STANDARD_REQUEST_SYNCH_FRAME        0x0C 
....................  
.................... //HID Class Setup bRequest Codes 
.................... #define USB_HID_REQUEST_GET_REPORT     0x01 
.................... #define USB_HID_REQUEST_GET_IDLE       0x02 
.................... #define USB_HID_REQUEST_GET_PROTOCOL   0x03 
.................... #define USB_HID_REQUEST_SET_REPORT     0x09 
.................... #define USB_HID_REQUEST_SET_IDLE       0x0A 
.................... #define USB_HID_REQUEST_SET_PROTOCOL   0x0B 
....................  
.................... //types of endpoints as defined in the descriptor 
.................... #define USB_ENDPOINT_TYPE_CONTROL      0x00 
.................... #define USB_ENDPOINT_TYPE_ISOCHRONOUS  0x01 
.................... #define USB_ENDPOINT_TYPE_BULK         0x02 
.................... #define USB_ENDPOINT_TYPE_INTERRUPT    0x03 
....................  
.................... //types of endpoints used internally in this api 
.................... #define USB_ENABLE_DISABLED     -1 
.................... #define USB_ENABLE_BULK         USB_ENDPOINT_TYPE_BULK 
.................... #define USB_ENABLE_ISOCHRONOUS  USB_ENDPOINT_TYPE_ISOCHRONOUS 
.................... #define USB_ENABLE_INTERRUPT    USB_ENDPOINT_TYPE_INTERRUPT 
.................... #define USB_ENABLE_CONTROL      USB_ENDPOINT_TYPE_CONTROL 
....................  
.................... //*** ENABLE RX ENDPOINTS AND BUFFERS 
....................  
.................... //--------- endpoint 0 defines ---------- 
.................... #define USB_EP0_TX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_ENABLE  USB_ENABLE_CONTROL 
.................... #define USB_EP0_RX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
.................... #define USB_EP0_TX_SIZE    USB_MAX_EP0_PACKET_LENGTH  //endpoint 0 is setup, and should always be the MAX_PACKET_LENGTH.  Slow speed specifies 8 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #ifndef USB_EP1_TX_ENABLE 
....................  #define USB_EP1_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP1_RX_ENABLE 
....................  #define USB_EP1_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP1_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_RX_SIZE 
....................   #undef USB_EP1_RX_SIZE 
....................  #endif 
....................  #define USB_EP1_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_RX_SIZE 
....................   #error You enabled EP1 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP1_TX_SIZE 
....................   #undef USB_EP1_TX_SIZE 
....................  #endif 
....................  #define USB_EP1_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP1_TX_SIZE 
....................   #error You enabled EP1 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #ifndef USB_EP2_TX_ENABLE 
....................  #define USB_EP2_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP2_RX_ENABLE 
....................  #define USB_EP2_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP2_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_RX_SIZE 
....................   #undef USB_EP2_RX_SIZE 
....................  #endif 
....................  #define USB_EP2_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_RX_SIZE 
....................   #error You enabled EP2 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP2_TX_SIZE 
....................   #undef USB_EP2_TX_SIZE 
....................  #endif 
....................  #define USB_EP2_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP2_TX_SIZE 
....................   #error You enabled EP2 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #ifndef USB_EP3_TX_ENABLE 
....................  #define USB_EP3_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP3_RX_ENABLE 
....................  #define USB_EP3_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP3_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_RX_SIZE 
....................   #undef USB_EP3_RX_SIZE 
....................  #endif 
....................  #define USB_EP3_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_RX_SIZE 
....................   #error You enabled EP3 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP3_TX_SIZE 
....................   #undef USB_EP3_TX_SIZE 
....................  #endif 
....................  #define USB_EP3_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP3_TX_SIZE 
....................   #error You enabled EP3 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #ifndef USB_EP4_TX_ENABLE 
....................  #define USB_EP4_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP4_RX_ENABLE 
....................  #define USB_EP4_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP4_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_RX_SIZE 
....................   #undef USB_EP4_RX_SIZE 
....................  #endif 
....................  #define USB_EP4_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_RX_SIZE 
....................   #error You enabled EP4 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP4_TX_SIZE 
....................   #undef USB_EP4_TX_SIZE 
....................  #endif 
....................  #define USB_EP4_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP4_TX_SIZE 
....................   #error You enabled EP4 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #ifndef USB_EP5_TX_ENABLE 
....................  #define USB_EP5_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP5_RX_ENABLE 
....................  #define USB_EP5_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP5_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_RX_SIZE 
....................   #undef USB_EP5_RX_SIZE 
....................  #endif 
....................  #define USB_EP5_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_RX_SIZE 
....................   #error You enabled EP5 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP5_TX_SIZE 
....................   #undef USB_EP5_TX_SIZE 
....................  #endif 
....................  #define USB_EP5_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP5_TX_SIZE 
....................   #error You enabled EP5 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #ifndef USB_EP6_TX_ENABLE 
....................  #define USB_EP6_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP6_RX_ENABLE 
....................  #define USB_EP6_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP6_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_RX_SIZE 
....................   #undef USB_EP6_RX_SIZE 
....................  #endif 
....................  #define USB_EP6_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_RX_SIZE 
....................   #error You enabled EP6 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP6_TX_SIZE 
....................   #undef USB_EP6_TX_SIZE 
....................  #endif 
....................  #define USB_EP6_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP6_TX_SIZE 
....................   #error You enabled EP6 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #ifndef USB_EP7_TX_ENABLE 
....................  #define USB_EP7_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP7_RX_ENABLE 
....................  #define USB_EP7_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP7_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_RX_SIZE 
....................   #undef USB_EP7_RX_SIZE 
....................  #endif 
....................  #define USB_EP7_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_RX_SIZE 
....................   #error You enabled EP7 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP7_TX_SIZE 
....................   #undef USB_EP7_TX_SIZE 
....................  #endif 
....................  #define USB_EP7_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP7_TX_SIZE 
....................   #error You enabled EP7 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #ifndef USB_EP8_TX_ENABLE 
....................  #define USB_EP8_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP8_RX_ENABLE 
....................  #define USB_EP8_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP8_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_RX_SIZE 
....................   #undef USB_EP8_RX_SIZE 
....................  #endif 
....................  #define USB_EP8_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_RX_SIZE 
....................   #error You enabled EP8 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP8_TX_SIZE 
....................   #undef USB_EP8_TX_SIZE 
....................  #endif 
....................  #define USB_EP8_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP8_TX_SIZE 
....................   #error You enabled EP8 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #ifndef USB_EP9_TX_ENABLE 
....................  #define USB_EP9_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP9_RX_ENABLE 
....................  #define USB_EP9_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP9_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_RX_SIZE 
....................   #undef USB_EP9_RX_SIZE 
....................  #endif 
....................  #define USB_EP9_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_RX_SIZE 
....................   #error You enabled EP9 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP9_TX_SIZE 
....................   #undef USB_EP9_TX_SIZE 
....................  #endif 
....................  #define USB_EP9_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP9_TX_SIZE 
....................   #error You enabled EP9 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #ifndef USB_EP10_TX_ENABLE 
....................  #define USB_EP10_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP10_RX_ENABLE 
....................  #define USB_EP10_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP10_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_RX_SIZE 
....................   #undef USB_EP10_RX_SIZE 
....................  #endif 
....................  #define USB_EP10_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_RX_SIZE 
....................   #error You enabled EP10 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP10_TX_SIZE 
....................   #undef USB_EP10_TX_SIZE 
....................  #endif 
....................  #define USB_EP10_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP10_TX_SIZE 
....................   #error You enabled EP10 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #ifndef USB_EP11_TX_ENABLE 
....................  #define USB_EP11_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP11_RX_ENABLE 
....................  #define USB_EP11_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP11_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_RX_SIZE 
....................   #undef USB_EP11_RX_SIZE 
....................  #endif 
....................  #define USB_EP11_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_RX_SIZE 
....................   #error You enabled EP11 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP11_TX_SIZE 
....................   #undef USB_EP11_TX_SIZE 
....................  #endif 
....................  #define USB_EP11_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP11_TX_SIZE 
....................   #error You enabled EP11 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #ifndef USB_EP12_TX_ENABLE 
....................  #define USB_EP12_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP12_RX_ENABLE 
....................  #define USB_EP12_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP12_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_RX_SIZE 
....................   #undef USB_EP12_RX_SIZE 
....................  #endif 
....................  #define USB_EP12_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_RX_SIZE 
....................   #error You enabled EP12 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP12_TX_SIZE 
....................   #undef USB_EP12_TX_SIZE 
....................  #endif 
....................  #define USB_EP12_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP12_TX_SIZE 
....................   #error You enabled EP12 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #ifndef USB_EP13_TX_ENABLE 
....................  #define USB_EP13_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP13_RX_ENABLE 
....................  #define USB_EP13_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP13_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_RX_SIZE 
....................   #undef USB_EP13_RX_SIZE 
....................  #endif 
....................  #define USB_EP13_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_RX_SIZE 
....................   #error You enabled EP13 for RX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP13_TX_SIZE 
....................   #undef USB_EP13_TX_SIZE 
....................  #endif 
....................  #define USB_EP13_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP13_TX_SIZE 
....................   #error You enabled EP13 for TX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #ifndef USB_EP14_TX_ENABLE 
....................  #define USB_EP14_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP14_RX_ENABLE 
....................  #define USB_EP14_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP14_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_RX_SIZE 
....................   #undef USB_EP14_RX_SIZE 
....................  #endif 
....................  #define USB_EP14_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_RX_SIZE 
....................   #error You enabled EP14 for RX but didn't specify endpoint size 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP14_TX_SIZE 
....................   #undef USB_EP14_TX_SIZE 
....................  #endif 
....................  #define USB_EP14_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP14_TX_SIZE 
....................   #error You enabled EP14 for TX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #ifndef USB_EP15_TX_ENABLE 
....................  #define USB_EP15_TX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
.................... #ifndef USB_EP15_RX_ENABLE 
....................  #define USB_EP15_RX_ENABLE USB_ENABLE_DISABLED 
.................... #endif 
....................  
.................... #if USB_EP15_RX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_RX_SIZE 
....................   #undef USB_EP15_RX_SIZE 
....................  #endif 
....................  #define USB_EP15_RX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_RX_SIZE 
....................   #error You enabled EP15 for RX but didn't specify endpoint size 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE==USB_ENABLE_DISABLED 
....................  #ifdef USB_EP15_TX_SIZE 
....................   #undef USB_EP15_TX_SIZE 
....................  #endif 
....................  #define USB_EP15_TX_SIZE 0 
.................... #else 
....................  #ifndef USB_EP15_TX_SIZE 
....................   #error You enabled EP15 for TX but didn't specify endpoint size 
....................  #endif   
.................... #endif 
....................  
.................... const unsigned int8 usb_ep_tx_type[16]={ 
....................   USB_EP0_TX_ENABLE, USB_EP1_TX_ENABLE, USB_EP2_TX_ENABLE, 
....................   USB_EP3_TX_ENABLE, USB_EP4_TX_ENABLE, USB_EP5_TX_ENABLE, 
....................   USB_EP6_TX_ENABLE, USB_EP7_TX_ENABLE, USB_EP8_TX_ENABLE, 
....................   USB_EP9_TX_ENABLE, USB_EP10_TX_ENABLE, USB_EP11_TX_ENABLE, 
....................   USB_EP12_TX_ENABLE, USB_EP13_TX_ENABLE, USB_EP14_TX_ENABLE, 
....................   USB_EP15_TX_ENABLE 
.................... }; 
....................  
.................... const unsigned int8 usb_ep_rx_type[16]={ 
....................   USB_EP0_RX_ENABLE, USB_EP1_RX_ENABLE, USB_EP2_RX_ENABLE, 
....................   USB_EP3_RX_ENABLE, USB_EP4_RX_ENABLE, USB_EP5_RX_ENABLE, 
....................   USB_EP6_RX_ENABLE, USB_EP7_RX_ENABLE, USB_EP8_RX_ENABLE, 
....................   USB_EP9_RX_ENABLE, USB_EP10_RX_ENABLE, USB_EP11_RX_ENABLE, 
....................   USB_EP12_RX_ENABLE, USB_EP13_RX_ENABLE, USB_EP14_RX_ENABLE, 
....................   USB_EP15_RX_ENABLE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_tx_size[16]={ 
....................   USB_EP0_TX_SIZE, USB_EP1_TX_SIZE, USB_EP2_TX_SIZE, 
....................   USB_EP3_TX_SIZE, USB_EP4_TX_SIZE, USB_EP5_TX_SIZE, 
....................   USB_EP6_TX_SIZE, USB_EP7_TX_SIZE, USB_EP8_TX_SIZE, 
....................   USB_EP9_TX_SIZE, USB_EP10_TX_SIZE, USB_EP11_TX_SIZE, 
....................   USB_EP12_TX_SIZE, USB_EP13_TX_SIZE, USB_EP14_TX_SIZE, 
....................   USB_EP15_TX_SIZE 
.................... }; 
....................  
.................... const unsigned int16 usb_ep_rx_size[16]={ 
....................   USB_EP0_RX_SIZE, USB_EP1_RX_SIZE, USB_EP2_RX_SIZE, 
....................   USB_EP3_RX_SIZE, USB_EP4_RX_SIZE, USB_EP5_RX_SIZE, 
....................   USB_EP6_RX_SIZE, USB_EP7_RX_SIZE, USB_EP8_RX_SIZE, 
....................   USB_EP9_RX_SIZE, USB_EP10_RX_SIZE, USB_EP11_RX_SIZE, 
....................   USB_EP12_RX_SIZE, USB_EP13_RX_SIZE, USB_EP14_RX_SIZE, 
....................   USB_EP15_RX_SIZE 
.................... }; 
....................  
.................... #ENDIF 
....................  
....................  
.................... #bit USBIE=getenv("BIT:USBIE") 
....................  
.................... //if you are worried that the PIC is not receiving packets because a bug in the 
.................... //DATA0/DATA1 synch code, you can set this to TRUE to ignore the DTS on 
.................... //receiving. 
.................... #ifndef USB_IGNORE_RX_DTS 
....................  #define USB_IGNORE_RX_DTS FALSE 
.................... #endif 
....................  
.................... #ifndef USB_IGNORE_TX_DTS 
....................  #define USB_IGNORE_TX_DTS FALSE 
.................... #endif 
....................  
.................... #if ((getenv("DEVICE")=="PIC18F87J50") || (getenv("DEVICE")=="PIC18F86J55") || \ 
....................      (getenv("DEVICE")=="PIC18F86J50") || (getenv("DEVICE")=="PIC18F85J50") || \ 
....................      (getenv("DEVICE")=="PIC18F67J50") || (getenv("DEVICE")=="PIC18F66J55") || \ 
....................      (getenv("DEVICE")=="PIC18F66J50") || (getenv("DEVICE")=="PIC18F65J50")) 
....................  #define __USB_87J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18F24K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF45K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18LF25K50") ||  \ 
....................        (getenv("DEVICE")=="PIC18LF24K50")) 
....................  #define __USB_45K50__ 
....................  #define USB_TOTAL_RAM_SPACE  1024 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16  
....................  #define USB_PIC_NO_USB_GPIO  //D+ and D- are not shared with any GPIO 
.................... #elif ((getenv("DEVICE")=="PIC18F24J50") || (getenv("DEVICE")=="PIC18F25J50") || \ 
....................        (getenv("DEVICE")=="PIC18F26J50") || (getenv("DEVICE")=="PIC18F44J50") || \ 
....................        (getenv("DEVICE")=="PIC18F45J50") || (getenv("DEVICE")=="PIC18F46J50")) 
....................  #define __USB_46J50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)getenv("RAM")-0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F2450") || (getenv("DEVICE")=="PIC18F4450")) 
....................  #define __USB_4450__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F13K50") || (getenv("DEVICE")=="PIC18F14K50") || \ 
....................        (getenv("DEVICE")=="PIC18LF13K50") || (getenv("DEVICE")=="PIC18LF14K50")) 
....................  #define __USB_K50__ //backwards compatability 
....................  #define __USB_14K50__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x100) 
....................  #define USB_RAM_START  0x200 
....................  #define USB_NUM_UEP 8 
....................  //technically this device supports 8 endpoints, but for RAM reasons you should 
....................  //attempt to only use the first 3 endpoints. 
....................  #define USB_LAST_ALLOWED_ENDPOINT  3 
.................... #elif ((getenv("DEVICE")=="PIC18F2455") || (getenv("DEVICE")=="PIC18F2550") || \ 
....................        (getenv("DEVICE")=="PIC18F4455") || (getenv("DEVICE")=="PIC18F4550") || \ 
....................        (getenv("DEVICE")=="PIC18F2458") || (getenv("DEVICE")=="PIC18F2553") || \ 
....................        (getenv("DEVICE")=="PIC18F4458") || (getenv("DEVICE")=="PIC18F4553") \ 
....................        ) 
....................  #define __USB_4550__ 
....................  #define USB_TOTAL_RAM_SPACE  ((unsigned int16)0x400) 
....................  #define USB_RAM_START  0x400 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #elif ((getenv("DEVICE")=="PIC18F26J53") || (getenv("DEVICE")=="PIC18F27J53") || \ 
....................        (getenv("DEVICE")=="PIC18F46J53") || (getenv("DEVICE")=="PIC18F47J53") \ 
....................        ) 
....................  #define __USB_18FJ53__ 
....................  #define USB_TOTAL_RAM_SPACE  (0xE00) //0x000:0xDFF.  save 0x00:0xFF for compiler use 
....................  #define USB_BDT_START  0xD00 
....................  #define USB_NUM_UEP 16 
....................  #define USB_LAST_ALLOWED_ENDPOINT  16 
.................... #else 
....................  #error Unknown PIC device, USB not supported in this library. 
.................... #endif 
....................  
.................... #if !defined(USB_BDT_START) 
.................... #define USB_BDT_START   USB_RAM_START 
.................... #endif 
....................  
.................... #if USB_EP15_TX_SIZE || USB_EP15_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  15 
.................... #elif USB_EP14_TX_SIZE || USB_EP14_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  14 
.................... #elif USB_EP13_TX_SIZE || USB_EP13_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  13 
.................... #elif USB_EP12_TX_SIZE || USB_EP12_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  12 
.................... #elif USB_EP11_TX_SIZE || USB_EP11_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  11 
.................... #elif USB_EP10_TX_SIZE || USB_EP10_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  10 
.................... #elif USB_EP9_TX_SIZE || USB_EP9_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  9 
.................... #elif USB_EP8_TX_SIZE || USB_EP8_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  8 
.................... #elif USB_EP7_TX_SIZE || USB_EP7_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  7 
.................... #elif USB_EP6_TX_SIZE || USB_EP6_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  6 
.................... #elif USB_EP5_TX_SIZE || USB_EP5_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  5 
.................... #elif USB_EP4_TX_SIZE || USB_EP4_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  4 
.................... #elif USB_EP3_TX_SIZE || USB_EP3_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  3 
.................... #elif USB_EP2_TX_SIZE || USB_EP2_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  2 
.................... #elif USB_EP1_TX_SIZE || USB_EP1_RX_SIZE 
....................  #define USB_LAST_DEFINED_ENDPOINT  1 
.................... #else 
....................  #define USB_LAST_DEFINED_ENDPOINT  0 
.................... #endif 
....................  
.................... #define USB_CONTROL_REGISTER_SIZE   ((USB_LAST_DEFINED_ENDPOINT+1)*8) 
....................  
.................... #define USB_DATA_BUFFER_NEEDED (USB_EP0_TX_SIZE+USB_EP0_RX_SIZE+USB_EP1_TX_SIZE+\ 
....................                            USB_EP1_RX_SIZE+USB_EP2_TX_SIZE+USB_EP2_RX_SIZE+\ 
....................                            USB_EP3_TX_SIZE+USB_EP3_RX_SIZE+USB_EP4_TX_SIZE+\ 
....................                            USB_EP4_RX_SIZE+USB_EP5_TX_SIZE+USB_EP5_RX_SIZE+\ 
....................                            USB_EP6_TX_SIZE+USB_EP6_RX_SIZE+USB_EP7_TX_SIZE+\ 
....................                            USB_EP7_RX_SIZE+USB_EP8_TX_SIZE+USB_EP8_RX_SIZE+\ 
....................                            USB_EP9_TX_SIZE+USB_EP9_RX_SIZE+USB_EP10_TX_SIZE+\ 
....................                            USB_EP10_RX_SIZE+USB_EP11_TX_SIZE+USB_EP11_RX_SIZE+\ 
....................                            USB_EP12_TX_SIZE+USB_EP12_RX_SIZE+USB_EP13_TX_SIZE+\ 
....................                            USB_EP13_RX_SIZE+USB_EP14_TX_SIZE+USB_EP14_RX_SIZE+\ 
....................                            USB_EP15_TX_SIZE+USB_EP15_RX_SIZE) 
....................  
.................... #if defined(USB_RAM_START) 
....................    #if ((USB_DATA_BUFFER_NEEDED+USB_CONTROL_REGISTER_SIZE) > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #else 
....................    #if (USB_DATA_BUFFER_NEEDED > USB_TOTAL_RAM_SPACE) 
....................       #error You are trying to allocate more memory for endpoints than the PIC can handle 
....................    #endif 
.................... #endif 
....................  
.................... #if (USB_LAST_DEFINED_ENDPOINT > USB_LAST_ALLOWED_ENDPOINT) 
....................  #error You are trying to use an invalid endpoint for this hardware! 
.................... #endif 
....................  
.................... #if defined(USB_RAM_START) 
.................... #define USB_DATA_BUFFER_LOCATION ((int16)USB_RAM_START+USB_CONTROL_REGISTER_SIZE) 
.................... #else 
.................... #define USB_DATA_BUFFER_LOCATION ((int8*)&g_USBRAM) 
.................... #endif 
....................  
.................... typedef struct 
.................... { 
....................    unsigned int8 stat; 
....................    unsigned int8 cnt; 
....................    unsigned int16 addr; 
.................... } STRUCT_BD; 
....................  
.................... #if defined(USB_RAM_START) 
.................... struct 
.................... { 
....................    struct 
....................    { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
....................    } bd[USB_LAST_DEFINED_ENDPOINT+1]; 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... #locate g_USBRAM=USB_RAM_START 
.................... #define g_USBBDT g_USBRAM.bd 
.................... #else 
.................... struct 
.................... { 
....................    union 
....................    { 
....................       struct 
....................       { 
....................          unsigned int8 ep0_rx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................          unsigned int8 ep0_tx_buffer[USB_MAX_EP0_PACKET_LENGTH]; 
....................           
....................          //these buffer definitions needed for CDC library 
....................         #if USB_EP1_RX_SIZE 
....................          unsigned int8 ep1_rx_buffer[USB_EP1_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP1_TX_SIZE 
....................          unsigned int8 ep1_tx_buffer[USB_EP1_TX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_RX_SIZE 
....................          unsigned int8 ep2_rx_buffer[USB_EP2_RX_SIZE]; 
....................         #endif 
....................         #if USB_EP2_TX_SIZE 
....................          unsigned int8 ep2_tx_buffer[USB_EP2_TX_SIZE]; 
....................         #endif 
....................       }; 
....................       unsigned int8 general[USB_DATA_BUFFER_NEEDED]; 
....................    } buffer; 
.................... } g_USBRAM; 
.................... struct 
.................... { 
....................       STRUCT_BD out;    //pc -> pic 
....................       STRUCT_BD in;     //pc <- pic 
.................... } g_USBBDT[USB_LAST_DEFINED_ENDPOINT+1]; 
.................... #locate g_USBBDT=USB_BDT_START 
.................... #endif 
....................  
.................... #define usb_ep0_rx_buffer g_USBRAM.buffer.ep0_rx_buffer 
.................... #define usb_ep0_tx_buffer g_USBRAM.buffer.ep0_tx_buffer 
....................  
.................... //these buffer definitions needed for CDC library 
.................... #define usb_ep1_rx_buffer g_USBRAM.buffer.ep1_rx_buffer 
.................... #define usb_ep1_tx_buffer g_USBRAM.buffer.ep1_tx_buffer 
.................... #define usb_ep2_rx_buffer g_USBRAM.buffer.ep2_rx_buffer 
.................... #define usb_ep2_tx_buffer g_USBRAM.buffer.ep2_tx_buffer 
....................  
.................... //if you enable this it will keep a counter of the 6 possible errors the 
.................... //pic can detect.  disabling this will save you ROM, RAM and execution time. 
.................... #if !defined(USB_USE_ERROR_COUNTER) 
....................    #define USB_USE_ERROR_COUNTER FALSE 
.................... #endif 
....................  
.................... #define USB_PING_PONG_MODE_OFF   0  //no ping pong 
.................... #define USB_PING_PONG_MODE_E0    1  //ping pong endpoint 0 only 
.................... #define USB_PING_PONG_MODE_ON    2  //ping pong all endpoints 
....................  
.................... //NOTE - PING PONG MODE IS NOT SUPPORTED BY CCS! 
.................... #if !defined(USB_PING_PONG_MODE) 
....................    #define USB_PING_PONG_MODE USB_PING_PONG_MODE_OFF 
.................... #endif 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................    unsigned int ERROR_COUNTER[6]; 
.................... #endif 
....................  
.................... //---pic18fxx5x memory locations 
.................... #if defined(__USB_4550__) || defined(__USB_4450__) 
....................    #byte UFRML   =  0xF66 
....................    #byte UFRMH   =  0xF67 
....................    #byte UIR     =  0xF68 
....................    #byte UIE     =  0xF69 
....................    #byte UEIR    =  0xF6A 
....................    #byte UEIE    =  0xF6B 
....................    #byte U1STAT   =  0xF6C 
....................    #byte UCON    =  0xF6D 
....................    #byte UADDR   =  0xF6E 
....................    #byte UCFG    =  0xF6F 
....................    #define  UEP0_LOC 0xF70 
.................... #elif defined(__USB_46J50__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #elif defined(__USB_14K50__) 
....................    #byte UFRML   =  0xF5D 
....................    #byte UFRMH   =  0xF5E 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF60 
....................    #byte UEIR    =  0xF5F 
....................    #byte UEIE    =  0xF5B 
....................    #byte U1STAT   =  0xF63 
....................    #byte UCON    =  0xF64 
....................    #byte UADDR   =  0xF5C 
....................    #byte UCFG    =  0xF61 
....................    #define  UEP0_LOC 0xF53 
.................... #elif defined(__USB_18FJ53__) 
....................    #byte UFRML   =  0xF60 
....................    #byte UFRMH   =  0xF61 
....................    #byte UIR     =  0xF62 
....................    #byte UIE     =  0xF36 
....................    #byte UEIR    =  0xF63 
....................    #byte UEIE    =  0xF37 
....................    #byte U1STAT   =  0xF64 
....................    #byte UCON    =  0xF65 
....................    #byte UADDR   =  0xF38 
....................    #byte UCFG    =  0xF39 
....................    #define  UEP0_LOC 0xF26 
.................... #else 
....................    #byte UFRML = getenv("SFR:UFRML") 
....................    #byte UFRMH = getenv("SFR:UFRMH") 
....................    #byte UIR = getenv("SFR:UIR") 
....................    #byte UIE = getenv("SFR:UIE") 
....................    #byte UEIR = getenv("SFR:UEIR") 
....................    #byte UEIE = getenv("SFR:UEIE") 
....................    #byte U1STAT = getenv("SFR:USTAT") 
....................    #byte UCON = getenv("SFR:UCON") 
....................    #byte UADDR = getenv("SFR:UADDR") 
....................    #byte UCFG = getenv("SFR:UCFG") 
.................... #endif 
....................  
.................... unsigned int8 USTATCopy; 
....................  
.................... unsigned int8 g_UEP[USB_NUM_UEP]; 
.................... #if defined(UEP0_LOC) 
.................... #locate g_UEP=UEP0_LOC 
.................... #else 
.................... #locate g_UEP=getenv("SFR:UEP0") 
.................... #endif 
.................... #define UEP(x) g_UEP[x] 
....................  
.................... #define BIT_SOF   6 
.................... #define BIT_STALL 5 
.................... #define BIT_IDLE  4 
.................... #define BIT_TRN   3 
.................... #define BIT_ACTV  2 
.................... #define BIT_UERR  1 
.................... #define BIT_URST  0 
....................  
.................... #BIT UIR_SOF = UIR.BIT_SOF 
.................... #BIT UIR_STALL = UIR.BIT_STALL 
.................... #BIT UIR_IDLE = UIR.BIT_IDLE 
.................... #BIT UIR_TRN = UIR.BIT_TRN 
.................... #BIT UIR_ACTV = UIR.BIT_ACTV 
.................... #BIT UIR_UERR = UIR.BIT_UERR 
.................... #BIT UIR_URST = UIR.BIT_URST 
....................  
.................... #BIT UIE_SOF = UIE.6 
.................... #BIT UIE_STALL = UIE.5 
.................... #BIT UIE_IDLE = UIE.4 
.................... #BIT UIE_TRN = UIE.3 
.................... #BIT UIE_ACTV = UIE.2 
.................... #BIT UIE_UERR = UIE.1 
.................... #BIT UIE_URST = UIE.0 
....................  
.................... #bit UCON_PBRST=UCON.6 
.................... #bit UCON_SE0=UCON.5 
.................... #bit UCON_PKTDIS=UCON.4 
.................... #bit UCON_USBEN=UCON.3 
.................... #bit UCON_RESUME=UCON.2 
.................... #bit UCON_SUSPND=UCON.1 
....................  
.................... #if (USB_PING_PONG_MODE==USB_PING_PONG_MODE_OFF) 
....................  #define EP_BDxST_O(x)    g_USBBDT[x].out.stat 
....................  #define EP_BDxCNT_O(x)   g_USBBDT[x].out.cnt 
....................  #define EP_BDxADR_O(x)   g_USBBDT[x].out.addr 
....................  #define EP_BDxST_I(x)    g_USBBDT[x].in.stat 
....................  #define EP_BDxCNT_I(x)   g_USBBDT[x].in.cnt 
....................  #define EP_BDxADR_I(x)   g_USBBDT[x].in.addr 
.................... #else 
.................... #error Right now this driver only supports no ping pong 
.................... #endif 
....................  
.................... //See UEPn (0xF70-0xF7F) 
.................... #define ENDPT_DISABLED   0x00   //endpoint not used 
.................... #define ENDPT_IN_ONLY   0x02    //endpoint supports IN transactions only 
.................... #define ENDPT_OUT_ONLY   0x04    //endpoint supports OUT transactions only 
.................... #define ENDPT_CONTROL   0x06    //Supports IN, OUT and CONTROL transactions - Only use with EP0 
.................... #define ENDPT_NON_CONTROL 0x0E  //Supports both IN and OUT transactions 
....................  
.................... //Define the states that the USB interface can be in 
.................... enum {USB_STATE_DETACHED=0, USB_STATE_ATTACHED=1, USB_STATE_POWERED=2, USB_STATE_DEFAULT=3, 
....................     USB_STATE_ADDRESS=4, USB_STATE_CONFIGURED=5} usb_state; 
....................  
.................... //--BDendST has their PIDs upshifed 2 
.................... #define USB_PIC_PID_IN       0x24  //device to host transactions 
.................... #define USB_PIC_PID_OUT      0x04  //host to device transactions 
.................... #define USB_PIC_PID_SETUP    0x34  //host to device setup transaction 
....................  
.................... #define USTAT_IN_E0        4 
.................... #define USTAT_OUT_SETUP_E0 0 
....................  
.................... #define __USB_UIF_RESET    0x01 
.................... #define __USB_UIF_ERROR    0x02 
.................... #define __USB_UIF_ACTIVE   0x04 
.................... #define __USB_UIF_TOKEN    0x08 
.................... #define __USB_UIF_IDLE     0x10 
.................... #define __USB_UIF_STALL    0x20 
.................... #define __USB_UIF_SOF      0x40 
....................  
.................... #if USB_USE_ERROR_COUNTER 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_ERROR|__USB_UIF_RESET 
.................... #else 
....................  #define STANDARD_INTS __USB_UIF_STALL|__USB_UIF_IDLE|__USB_UIF_TOKEN|__USB_UIF_ACTIVE|__USB_UIF_RESET 
.................... #endif 
....................  
.................... #define __USB_UCFG_UTEYE   0x80 
.................... #if defined(__USB_4550__) 
....................  #define __USB_UCFG_UOEMON  0x40 
.................... #endif 
.................... #define __USB_UCFG_UPUEN   0x10 
.................... #if !defined(__USB_14K50__) 
....................  #define __USB_UCFG_UTRDIS  0x08 
.................... #endif 
.................... #define __USB_UCFG_FSEN    0x04 
....................  
.................... #if defined(USB_EXTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  0 
.................... #endif 
....................  
.................... #if defined(USB_INTERNAL_PULLUPS) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if !defined(__USB_UCFG_MY_UPUEN) 
....................  #define __USB_UCFG_MY_UPUEN  __USB_UCFG_UPUEN 
.................... #endif 
....................  
.................... #if USB_USE_FULL_SPEED 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | __USB_UCFG_FSEN | USB_PING_PONG_MODE) 
.................... #else 
....................    #define __UCFG_VAL_ENABLED__ (__USB_UCFG_MY_UPUEN | USB_PING_PONG_MODE); 
.................... #endif 
....................  
.................... #if defined(__USB_UCFG_UTRDIS) 
....................  #define __UCFG_VAL_DISABLED__    __USB_UCFG_UTRDIS 
.................... #else 
....................  #define __UCFG_VAL_DISABLED__   0 
.................... #endif 
....................  
....................  
.................... unsigned int8 __setup_0_tx_size; 
....................  
.................... //interrupt handler, specific to PIC18Fxx5x peripheral only 
.................... void usb_handle_interrupt(); 
.................... void usb_isr_rst(); 
.................... void usb_isr_uerr(); 
.................... void usb_isr_sof(void); 
.................... void usb_isr_activity(); 
.................... void usb_isr_uidle(); 
.................... void usb_isr_tok_dne(); 
.................... void usb_isr_stall(void); 
.................... void usb_init_ep0_setup(void); 
....................  
.................... #if defined(USB_ISR_POLLING) 
.................... void usb_isr(void); 
.................... #endif 
....................  
.................... //// BEGIN User Functions: 
....................  
.................... // see usb_hw_layer.h for more documentation 
.................... int1 usb_kbhit(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_O(en),7))); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_tbe(unsigned int8 en) 
.................... { 
....................    return((UEP(en)!=ENDPT_DISABLED)&&(!bit_test(EP_BDxST_I(en),7))); 
*
0AAA:  CLRF   03
0AAC:  MOVF   x6E,W
0AAE:  ADDLW  70
0AB0:  MOVWF  FE9
0AB2:  MOVLW  0F
0AB4:  ADDWFC 03,W
0AB6:  MOVWF  FEA
0AB8:  MOVF   FEF,F
0ABA:  BZ    0AE0
0ABC:  MOVF   x6E,W
0ABE:  MULLW  08
0AC0:  MOVF   FF3,W
0AC2:  CLRF   x70
0AC4:  MOVWF  x6F
0AC6:  MOVLW  04
0AC8:  ADDWF  x6F,F
0ACA:  MOVLW  00
0ACC:  ADDWFC x70,F
0ACE:  MOVFF  6F,FE9
0AD2:  MOVLW  04
0AD4:  ADDWF  x70,W
0AD6:  MOVWF  FEA
0AD8:  MOVFF  FEF,71
0ADC:  BTFSS  x71.7
0ADE:  BRA    0AE4
0AE0:  MOVLW  00
0AE2:  BRA    0AE6
0AE4:  MOVLW  01
0AE6:  MOVWF  01
0AE8:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_detach(void) 
.................... { 
....................    UCON = 0;  //disable USB hardware 
*
105A:  CLRF   F6D
....................    UIE = 0;   //disable USB interrupts 
105C:  CLRF   F69
....................    UCFG = __UCFG_VAL_DISABLED__; 
105E:  MOVLW  08
1060:  MOVWF  F6F
....................  
....................    // set D+/D- to inputs 
....................   #if defined(__USB_87J50__) 
....................    set_tris_f(get_tris_f() | 0x18); 
....................   #elif defined(__USB_14K50__) 
....................    set_tris_a(get_tris_a() | 0x3); 
....................   #elif !defined(USB_PIC_NO_USB_GPIO) 
....................    set_tris_c(get_tris_c() | 0x30); //pin_c4 and pin_c5 
1062:  MOVF   F94,W
1064:  IORLW  30
1066:  MOVWF  F94
....................   #endif 
....................    
....................    usb_state = USB_STATE_DETACHED; 
1068:  CLRF   1F
106A:  CLRF   16
106C:  BTFSC  FF2.7
106E:  BSF    16.7
1070:  BCF    FF2.7
....................     
....................    usb_token_reset();              //clear the chapter9 stack 
1072:  CALL   0312
1076:  BTFSC  16.7
1078:  BSF    FF2.7
107A:  GOTO   1080 (RETURN)
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_attach(void)  
*
10D2:  CLRF   16
10D4:  BTFSC  FF2.7
10D6:  BSF    16.7
10D8:  BCF    FF2.7
.................... { 
....................    usb_token_reset(); 
10DA:  CALL   0312
10DE:  BTFSC  16.7
10E0:  BSF    FF2.7
....................    UCON = 0; 
10E2:  CLRF   F6D
....................    UCFG = __UCFG_VAL_ENABLED__; 
10E4:  MOVLW  14
10E6:  MOVWF  F6F
....................    UIE = 0;                                // Mask all USB interrupts 
10E8:  CLRF   F69
....................    UCON_USBEN = 1;                     // Enable module & attach to bus 
10EA:  BSF    F6D.3
....................    usb_state = USB_STATE_ATTACHED;      // Defined in usbmmap.c & .h 
10EC:  MOVLW  01
10EE:  MOVWF  1F
10F0:  GOTO   10FA (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init_cs(void) 
.................... { 
....................    usb_detach(); 
*
107E:  BRA    105A
1080:  GOTO   1672 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_task(void)  
.................... { 
....................   #if defined(USB_ISR_POLLING) 
....................    if (interrupt_active(INT_USB)) 
....................    { 
....................       usb_isr(); 
....................    } 
....................   #endif 
....................  
....................   #if defined(USB_CDC_DELAYED_FLUSH) 
....................    if (usb_enumerated()) 
....................    { 
....................       usb_cdc_flush_out_buffer(); 
....................    } 
....................   #endif 
....................  
....................    if (usb_attached())  
....................    { 
....................       if (UCON_USBEN==0)  
*
10F4:  BTFSC  F6D.3
10F6:  BRA    10FA
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: ATTACH"); 
....................          usb_attach(); 
10F8:  BRA    10D2
....................       } 
....................    } 
....................    else  
....................    { 
....................       if (UCON_USBEN==1)   
....................       { 
....................          debug_usb(debug_putc, "\r\n\nUSB TASK: DE-ATTACH"); 
....................          usb_detach(); 
....................       } 
....................    } 
....................  
....................    if ((usb_state == USB_STATE_ATTACHED)&&(!UCON_SE0))  
10FA:  DECFSZ 1F,W
10FC:  BRA    1114
10FE:  BTFSC  F6D.5
1100:  BRA    1114
....................    { 
....................       UIR=0; 
1102:  CLRF   F68
....................       UIE=0; 
1104:  CLRF   F69
....................      #if !defined(USB_ISR_POLLING) 
....................       enable_interrupts(INT_USB); 
1106:  BSF    FA0.5
....................       enable_interrupts(GLOBAL); 
1108:  MOVLW  C0
110A:  IORWF  FF2,F
....................      #endif 
....................       UIE=__USB_UIF_IDLE | __USB_UIF_RESET;  //enable IDLE and RESET USB ISR 
110C:  MOVLW  11
110E:  MOVWF  F69
....................       usb_state=USB_STATE_POWERED; 
1110:  MOVLW  02
1112:  MOVWF  1F
....................       debug_usb(debug_putc, "\r\n\nUSB TASK: POWERED"); 
....................    } 
1114:  GOTO   16BE (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_init(void)  
.................... { 
....................    usb_init_cs(); 
....................  
....................    do  
....................    { 
....................       usb_task(); 
....................    } while (usb_state != USB_STATE_POWERED); 
.................... } 
....................  
....................  
.................... // see pic18_usb.h for documentation 
.................... int1 usb_flush_in(int8 endpoint, int16 len, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................  
....................    debug_usb(debug_putc,"\r\nPUT %X %U %LU",endpoint, tgl, len); 
....................  
....................    if (usb_tbe(endpoint))  
*
0AEA:  MOVFF  69,6E
0AEE:  RCALL  0AAA
0AF0:  MOVF   01,F
0AF2:  BZ    0BBA
....................    { 
....................       EP_BDxCNT_I(endpoint)=len; 
0AF4:  MOVF   x69,W
0AF6:  MULLW  08
0AF8:  MOVF   FF3,W
0AFA:  CLRF   x6F
0AFC:  MOVWF  x6E
0AFE:  MOVLW  04
0B00:  ADDWF  x6E,F
0B02:  MOVLW  00
0B04:  ADDWFC x6F,F
0B06:  MOVLW  01
0B08:  ADDWF  x6E,W
0B0A:  MOVWF  01
0B0C:  MOVLW  00
0B0E:  ADDWFC x6F,W
0B10:  MOVWF  03
0B12:  MOVFF  01,FE9
0B16:  MOVLW  04
0B18:  ADDWF  03,W
0B1A:  MOVWF  FEA
0B1C:  MOVFF  6A,FEF
....................  
....................       debug_display_ram(len, EP_BDxADR_I(endpoint)); 
....................  
....................      #if USB_IGNORE_TX_DTS 
....................       i=0x80; 
....................      #else 
....................       if (tgl == USB_DTS_TOGGLE)  
0B20:  MOVF   x6C,W
0B22:  SUBLW  02
0B24:  BNZ   0B54
....................       { 
....................          i = EP_BDxST_I(endpoint); 
0B26:  MOVF   x69,W
0B28:  MULLW  08
0B2A:  MOVF   FF3,W
0B2C:  CLRF   x6F
0B2E:  MOVWF  x6E
0B30:  MOVLW  04
0B32:  ADDWF  x6E,F
0B34:  MOVLW  00
0B36:  ADDWFC x6F,F
0B38:  MOVFF  6E,FE9
0B3C:  MOVLW  04
0B3E:  ADDWF  x6F,W
0B40:  MOVWF  FEA
0B42:  MOVFF  FEF,6D
....................          if (bit_test(i,6)) 
0B46:  BTFSS  x6D.6
0B48:  BRA    0B4E
....................             tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0B4A:  CLRF   x6C
0B4C:  BRA    0B52
....................          else 
....................             tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0B4E:  MOVLW  01
0B50:  MOVWF  x6C
....................       } 
0B52:  BRA    0B7A
....................       else if (tgl == USB_DTS_USERX)  
0B54:  MOVF   x6C,W
0B56:  SUBLW  04
0B58:  BNZ   0B7A
....................       { 
....................          i = EP_BDxST_O(endpoint); 
0B5A:  MOVF   x69,W
0B5C:  MULLW  08
0B5E:  MOVF   FF3,W
0B60:  CLRF   x6F
0B62:  MOVWF  FE9
0B64:  MOVLW  04
0B66:  ADDWF  x6F,W
0B68:  MOVWF  FEA
0B6A:  MOVFF  FEF,6D
....................          if (bit_test(i,6)) 
0B6E:  BTFSS  x6D.6
0B70:  BRA    0B78
....................             tgl = USB_DTS_DATA1; 
0B72:  MOVLW  01
0B74:  MOVWF  x6C
0B76:  BRA    0B7A
....................          else 
....................             tgl = USB_DTS_DATA0; 
0B78:  CLRF   x6C
....................       } 
....................       if (tgl == USB_DTS_DATA1)  
0B7A:  DECFSZ x6C,W
0B7C:  BRA    0B84
....................          i=0xC8;  //DATA1, UOWN 
0B7E:  MOVLW  C8
0B80:  MOVWF  x6D
0B82:  BRA    0B88
....................       else //if (tgl == USB_DTS_DATA0)  
....................          i=0x88; //DATA0, UOWN 
0B84:  MOVLW  88
0B86:  MOVWF  x6D
....................      #endif 
....................  
....................       //set BC8 and BC9 
....................       if (bit_test(len,8)) {bit_set(i,0);} 
0B88:  BTFSS  x6B.0
0B8A:  BRA    0B8E
0B8C:  BSF    x6D.0
....................       if (bit_test(len,9)) {bit_set(i,1);} 
0B8E:  BTFSS  x6B.1
0B90:  BRA    0B94
0B92:  BSF    x6D.1
....................  
....................       debug_usb(debug_putc, " %X", i); 
....................  
....................       EP_BDxST_I(endpoint) = i;//save changes 
0B94:  MOVF   x69,W
0B96:  MULLW  08
0B98:  MOVF   FF3,W
0B9A:  CLRF   x6F
0B9C:  MOVWF  x6E
0B9E:  MOVLW  04
0BA0:  ADDWF  x6E,F
0BA2:  MOVLW  00
0BA4:  ADDWFC x6F,F
0BA6:  MOVFF  6E,FE9
0BAA:  MOVLW  04
0BAC:  ADDWF  x6F,W
0BAE:  MOVWF  FEA
0BB0:  MOVFF  6D,FEF
....................        
....................       //putc('!'); 
....................        
....................       return(1); 
0BB4:  MOVLW  01
0BB6:  MOVWF  01
0BB8:  BRA    0BBE
....................    } 
....................    else  
....................    { 
....................       //putc('_'); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................    return(0); 
0BBA:  MOVLW  00
0BBC:  MOVWF  01
0BBE:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl)  
*
1542:  CLRF   16
1544:  BTFSC  FF2.7
1546:  BSF    16.7
1548:  BCF    FF2.7
.................... { 
....................    unsigned int8 * buff_add;     
....................  
....................    if (usb_tbe(endpoint))  
154A:  MOVFF  55,6E
154E:  CALL   0AAA
1552:  BTFSC  16.7
1554:  BSF    FF2.7
1556:  MOVF   01,F
1558:  BZ    15E0
....................    { 
....................       buff_add = EP_BDxADR_I(endpoint); 
155A:  MOVF   55,W
155C:  MULLW  08
155E:  MOVF   FF3,W
1560:  CLRF   5E
1562:  MOVWF  5D
1564:  MOVLW  04
1566:  ADDWF  5D,F
1568:  MOVLW  00
156A:  ADDWFC 5E,F
156C:  MOVLW  02
156E:  ADDWF  5D,W
1570:  MOVWF  01
1572:  MOVLW  00
1574:  ADDWFC 5E,W
1576:  MOVWF  03
1578:  MOVFF  01,FE9
157C:  MOVLW  04
157E:  ADDWF  03,W
1580:  MOVWF  FEA
1582:  MOVFF  FEC,5C
1586:  MOVF   FED,F
1588:  MOVFF  FEF,5B
....................       memcpy(buff_add, ptr, len);      
158C:  MOVFF  5C,FEA
1590:  MOVFF  5B,FE9
1594:  MOVFF  57,FE2
1598:  MOVFF  56,FE1
159C:  MOVFF  59,02
15A0:  MOVFF  58,01
15A4:  MOVF   01,F
15A6:  BZ    15AC
15A8:  INCF   02,F
15AA:  BRA    15B0
15AC:  MOVF   02,F
15AE:  BZ    15BC
15B0:  MOVFF  FE6,FEE
15B4:  DECFSZ 01,F
15B6:  BRA    15B0
15B8:  DECFSZ 02,F
15BA:  BRA    15B0
15BC:  CLRF   16
15BE:  BTFSC  FF2.7
15C0:  BSF    16.7
15C2:  BCF    FF2.7
....................        
....................       return(usb_flush_in(endpoint, len, tgl)); 
15C4:  MOVFF  55,69
15C8:  MOVFF  59,6B
15CC:  MOVFF  58,6A
15D0:  MOVFF  5A,6C
15D4:  CALL   0AEA
15D8:  BTFSC  16.7
15DA:  BSF    FF2.7
15DC:  MOVF   01,W
15DE:  BRA    15E4
....................    } 
....................    else  
....................    { 
....................       //putc('-'); 
....................       //printf("%X", EP_BDxST_I(endpoint)); 
....................       debug_usb(debug_putc,"\r\nPUT ERR"); 
....................    } 
....................  
....................    return(0); 
15E0:  MOVLW  00
15E2:  MOVWF  01
15E4:  GOTO   176C (RETURN)
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... void usb_flush_out(int8 endpoint, USB_DTS_BIT tgl)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 len; 
....................  
....................   #if USB_IGNORE_RX_DTS 
....................    if (tgl == USB_DTS_STALL)  
....................    { 
....................       debug_usb(debug_putc, '*'); 
....................       EP_BDxCNT_O(endpoint) = 0x84; 
....................       EP_BDxST_I(endpoint) = 0x84; 
....................       return; 
....................    } 
....................    else 
....................       i=0x80; 
....................   #else 
....................    i = EP_BDxST_O(endpoint); 
*
09E4:  MOVF   x69,W
09E6:  MULLW  08
09E8:  MOVF   FF3,W
09EA:  CLRF   x6F
09EC:  MOVWF  FE9
09EE:  MOVLW  04
09F0:  ADDWF  x6F,W
09F2:  MOVWF  FEA
09F4:  MOVFF  FEF,6B
....................    if (tgl == USB_DTS_TOGGLE)  
09F8:  MOVF   x6A,W
09FA:  SUBLW  02
09FC:  BNZ   0A0A
....................    { 
....................       if (bit_test(i,6)) 
09FE:  BTFSS  x6B.6
0A00:  BRA    0A06
....................          tgl = USB_DTS_DATA0;  //was DATA1, goto DATA0 
0A02:  CLRF   x6A
0A04:  BRA    0A0A
....................       else 
....................          tgl = USB_DTS_DATA1;  //was DATA0, goto DATA1 
0A06:  MOVLW  01
0A08:  MOVWF  x6A
....................    } 
....................    if (tgl == USB_DTS_STALL)  
0A0A:  MOVF   x6A,W
0A0C:  SUBLW  03
0A0E:  BNZ   0A36
....................    { 
....................       i = 0x84; 
0A10:  MOVLW  84
0A12:  MOVWF  x6B
....................       EP_BDxST_I(endpoint) = 0x84; //stall both in and out endpoints 
0A14:  MOVF   x69,W
0A16:  MULLW  08
0A18:  MOVF   FF3,W
0A1A:  CLRF   x6F
0A1C:  MOVWF  x6E
0A1E:  MOVLW  04
0A20:  ADDWF  x6E,F
0A22:  MOVLW  00
0A24:  ADDWFC x6F,F
0A26:  MOVFF  6E,FE9
0A2A:  MOVLW  04
0A2C:  ADDWF  x6F,W
0A2E:  MOVWF  FEA
0A30:  MOVLW  84
0A32:  MOVWF  FEF
....................    } 
0A34:  BRA    0A44
....................    else if (tgl == USB_DTS_DATA1) 
0A36:  DECFSZ x6A,W
0A38:  BRA    0A40
....................       i = 0xC8;  //DATA1, UOWN 
0A3A:  MOVLW  C8
0A3C:  MOVWF  x6B
0A3E:  BRA    0A44
....................    else //if (tgl == USB_DTS_DATA0)  
....................       i = 0x88; //DATA0, UOWN 
0A40:  MOVLW  88
0A42:  MOVWF  x6B
....................   #endif 
....................  
....................    //bit_clear(__usb_kbhit_status,endpoint); 
....................  
....................    len = usb_ep_rx_size[endpoint]; 
0A44:  BCF    FD8.0
0A46:  RLCF   x69,W
0A48:  CLRF   03
0A4A:  MOVFF  FF2,6E
0A4E:  BCF    FF2.7
0A50:  CALL   00DA
0A54:  TBLRD*+
0A56:  MOVFF  FF5,03
0A5A:  BTFSC  x6E.7
0A5C:  BSF    FF2.7
0A5E:  MOVWF  x6C
0A60:  MOVFF  03,6D
....................    EP_BDxCNT_O(endpoint) = len; 
0A64:  MOVF   x69,W
0A66:  MULLW  08
0A68:  MOVF   FF3,W
0A6A:  CLRF   x6F
0A6C:  MOVWF  x6E
0A6E:  MOVLW  01
0A70:  ADDWF  x6E,W
0A72:  MOVWF  01
0A74:  MOVLW  00
0A76:  ADDWFC x6F,W
0A78:  MOVWF  03
0A7A:  MOVFF  01,FE9
0A7E:  MOVLW  04
0A80:  ADDWF  03,W
0A82:  MOVWF  FEA
0A84:  MOVFF  6C,FEF
....................    if (bit_test(len,8)) {bit_set(i,0);} 
0A88:  BTFSS  x6D.0
0A8A:  BRA    0A8E
0A8C:  BSF    x6B.0
....................    if (bit_test(len,9)) {bit_set(i,1);} 
0A8E:  BTFSS  x6D.1
0A90:  BRA    0A94
0A92:  BSF    x6B.1
....................  
....................    EP_BDxST_O(endpoint) = i; 
0A94:  MOVF   x69,W
0A96:  MULLW  08
0A98:  MOVF   FF3,W
0A9A:  CLRF   x6F
0A9C:  MOVWF  FE9
0A9E:  MOVLW  04
0AA0:  ADDWF  x6F,W
0AA2:  MOVWF  FEA
0AA4:  MOVFF  6B,FEF
0AA8:  RETURN 0
.................... } 
....................  
.................... // see pic18_usb.h for documentation 
.................... unsigned int16 usb_rx_packet_size(unsigned int8 endpoint)  
.................... { 
....................    return(EP_BDxCNT_O(endpoint)); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN Hardware layer functions required by USB. 
....................  
.................... /***************************************************************************** 
.................... /* usb_get_packet_buffer(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer. 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB buffer and puts into local PIC  
.................... /*          RAM. 
.................... /*          Does not mark the endpoint as ready for more data.  Once you are 
.................... /*          done with data, call usb_flush_out() to mark the endpoint ready 
.................... /*          to receive more data. 
.................... /* 
.................... /*****************************************************************************/ 
.................... static int16 usb_get_packet_buffer(int8 endpoint, int8 *ptr, int16 max)  
.................... { 
....................    unsigned int8 * al; 
....................    unsigned int8 st; 
....................    unsigned int16 i; 
....................  
....................    al = EP_BDxADR_O(endpoint); 
....................    i = EP_BDxCNT_O(endpoint); 
....................    st = EP_BDxST_O(endpoint); 
....................  
....................    //read BC8 and BC9 
....................    if (bit_test(st,0)) {bit_set(i,8);} 
....................    if (bit_test(st,1)) {bit_set(i,9);} 
....................  
....................    if (i < max) {max = i;} 
....................     
....................    memcpy(ptr, al ,max); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max) 
.................... { 
....................    max = usb_get_packet_buffer(endpoint, ptr, max); 
....................    usb_flush_out(endpoint, USB_DTS_TOGGLE); 
....................  
....................    return(max); 
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_stall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
08AC:  BCF    x6A.0
08AE:  BTFSC  x69.7
08B0:  BSF    x6A.0
....................    endpoint &= 0x7F; 
08B2:  BCF    x69.7
....................     
....................    if (direction)  
08B4:  BTFSS  x6A.0
08B6:  BRA    08DA
....................    { 
....................       EP_BDxST_I(endpoint) = 0x84; 
08B8:  MOVF   x69,W
08BA:  MULLW  08
08BC:  MOVF   FF3,W
08BE:  CLRF   x6C
08C0:  MOVWF  x6B
08C2:  MOVLW  04
08C4:  ADDWF  x6B,F
08C6:  MOVLW  00
08C8:  ADDWFC x6C,F
08CA:  MOVFF  6B,FE9
08CE:  MOVLW  04
08D0:  ADDWF  x6C,W
08D2:  MOVWF  FEA
08D4:  MOVLW  84
08D6:  MOVWF  FEF
....................    } 
08D8:  BRA    08EE
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x84; 
08DA:  MOVF   x69,W
08DC:  MULLW  08
08DE:  MOVF   FF3,W
08E0:  CLRF   x6C
08E2:  MOVWF  FE9
08E4:  MOVLW  04
08E6:  ADDWF  x6C,W
08E8:  MOVWF  FEA
08EA:  MOVLW  84
08EC:  MOVWF  FEF
....................    } 
08EE:  GOTO   0978 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_unstall_ep(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
0868:  BCF    x6A.0
086A:  BTFSC  x69.7
086C:  BSF    x6A.0
....................    endpoint &= 0x7F; 
086E:  BCF    x69.7
....................     
....................    if (direction)  
0870:  BTFSS  x6A.0
0872:  BRA    0896
....................    { 
....................      #if USB_IGNORE_RX_DTS 
....................       EP_BDxST_I(endpoint) = 0x80; 
....................      #else 
....................       EP_BDxST_I(endpoint) = 0x88; 
0874:  MOVF   x69,W
0876:  MULLW  08
0878:  MOVF   FF3,W
087A:  CLRF   x6C
087C:  MOVWF  x6B
087E:  MOVLW  04
0880:  ADDWF  x6B,F
0882:  MOVLW  00
0884:  ADDWFC x6C,F
0886:  MOVFF  6B,FE9
088A:  MOVLW  04
088C:  ADDWF  x6C,W
088E:  MOVWF  FEA
0890:  MOVLW  88
0892:  MOVWF  FEF
....................      #endif 
....................    } 
0894:  BRA    08A8
....................    else  
....................    { 
....................       EP_BDxST_O(endpoint) = 0x00; 
0896:  MOVF   x69,W
0898:  MULLW  08
089A:  MOVF   FF3,W
089C:  CLRF   x6C
089E:  MOVWF  FE9
08A0:  MOVLW  04
08A2:  ADDWF  x6C,W
08A4:  MOVWF  FEA
08A6:  CLRF   FEF
....................    } 
08A8:  GOTO   096C (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................    unsigned int8 st; 
....................     
....................    direction = bit_test(endpoint,7); 
*
08F2:  BCF    x6A.0
08F4:  BTFSC  x69.7
08F6:  BSF    x6A.0
....................    endpoint &= 0x7F; 
08F8:  BCF    x69.7
....................     
....................    if (direction)  
08FA:  BTFSS  x6A.0
08FC:  BRA    0920
....................    { 
....................       st=EP_BDxST_I(endpoint); 
08FE:  MOVF   x69,W
0900:  MULLW  08
0902:  MOVF   FF3,W
0904:  CLRF   x6D
0906:  MOVWF  x6C
0908:  MOVLW  04
090A:  ADDWF  x6C,F
090C:  MOVLW  00
090E:  ADDWFC x6D,F
0910:  MOVFF  6C,FE9
0914:  MOVLW  04
0916:  ADDWF  x6D,W
0918:  MOVWF  FEA
091A:  MOVFF  FEF,6B
....................    } 
091E:  BRA    0934
....................    else  
....................    { 
....................       st=EP_BDxST_O(endpoint); 
0920:  MOVF   x69,W
0922:  MULLW  08
0924:  MOVF   FF3,W
0926:  CLRF   x6D
0928:  MOVWF  FE9
092A:  MOVLW  04
092C:  ADDWF  x6D,W
092E:  MOVWF  FEA
0930:  MOVFF  FEF,6B
....................    } 
....................     
....................    return(bit_test(st,7) && bit_test(st,2)); 
0934:  BTFSS  x6B.7
0936:  BRA    093C
0938:  BTFSC  x6B.2
093A:  BRA    0940
093C:  MOVLW  00
093E:  BRA    0942
0940:  MOVLW  01
0942:  MOVWF  01
0944:  GOTO   098C (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_address(unsigned int8 address)  
.................... { 
....................    UADDR = address; 
*
0BC6:  MOVFF  6A,F6E
....................     
....................    if (address)  
0BCA:  MOVF   x6A,F
0BCC:  BZ    0BD4
....................    { 
....................       usb_state = USB_STATE_ADDRESS; 
0BCE:  MOVLW  04
0BD0:  MOVWF  1F
....................    } 
0BD2:  BRA    0BD8
....................    else  
....................    { 
....................       usb_state = USB_STATE_POWERED; 
0BD4:  MOVLW  02
0BD6:  MOVWF  1F
....................    } 
0BD8:  GOTO   0BE6 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_set_configured(unsigned int8 config)  
.................... { 
....................    unsigned int8 en; 
....................    unsigned int16 addy; 
....................    unsigned int8 new_uep; 
....................    unsigned int16 len; 
....................    unsigned int8 i; 
....................     
....................    if (config == 0) 
*
056E:  MOVF   x69,F
0570:  BNZ   057A
....................    { 
....................       // if config=0 then set addressed state 
....................       usb_state = USB_STATE_ADDRESS; 
0572:  MOVLW  04
0574:  MOVWF  1F
....................       usb_disable_endpoints(); 
0576:  RCALL  02FC
....................    } 
0578:  BRA    071C
....................    else  
....................    { 
....................       // else set configed state 
....................       usb_state = USB_STATE_CONFIGURED;  
057A:  MOVLW  05
057C:  MOVWF  1F
....................       addy = (unsigned int16)USB_DATA_BUFFER_LOCATION+(2*USB_MAX_EP0_PACKET_LENGTH); 
057E:  MOVLW  04
0580:  MOVWF  x6C
0582:  MOVLW  90
0584:  MOVWF  x6B
....................       for (en=1; en<USB_NUM_UEP; en++)  
0586:  MOVLW  01
0588:  MOVWF  x6A
058A:  MOVF   x6A,W
058C:  SUBLW  0F
058E:  BTFSS  FD8.0
0590:  BRA    071C
....................       { 
....................          // enable and config endpoints based upon user configuration 
....................          usb_disable_endpoint(en); 
0592:  MOVFF  6A,72
0596:  RCALL  02B0
....................          new_uep = 0; 
0598:  CLRF   x6D
....................          if (usb_ep_rx_type[en] != USB_ENABLE_DISABLED)  
059A:  CLRF   03
059C:  MOVF   x6A,W
059E:  MOVFF  FF2,71
05A2:  BCF    FF2.7
05A4:  RCALL  00BA
05A6:  BTFSC  x71.7
05A8:  BSF    FF2.7
05AA:  SUBLW  FF
05AC:  BZ    0660
....................          { 
....................             new_uep = 0x04; 
05AE:  MOVLW  04
05B0:  MOVWF  x6D
....................             len = usb_ep_rx_size[en]; 
05B2:  BCF    FD8.0
05B4:  RLCF   x6A,W
05B6:  CLRF   03
05B8:  MOVFF  FF2,71
05BC:  BCF    FF2.7
05BE:  RCALL  00DA
05C0:  TBLRD*+
05C2:  MOVFF  FF5,03
05C6:  BTFSC  x71.7
05C8:  BSF    FF2.7
05CA:  MOVWF  x6E
05CC:  MOVFF  03,6F
....................             EP_BDxCNT_O(en) = len; 
05D0:  MOVF   x6A,W
05D2:  MULLW  08
05D4:  MOVF   FF3,W
05D6:  CLRF   x72
05D8:  MOVWF  x71
05DA:  MOVLW  01
05DC:  ADDWF  x71,W
05DE:  MOVWF  01
05E0:  MOVLW  00
05E2:  ADDWFC x72,W
05E4:  MOVWF  03
05E6:  MOVFF  01,FE9
05EA:  MOVLW  04
05EC:  ADDWF  03,W
05EE:  MOVWF  FEA
05F0:  MOVFF  6E,FEF
....................             EP_BDxADR_O(en) = addy; 
05F4:  MOVF   x6A,W
05F6:  MULLW  08
05F8:  MOVF   FF3,W
05FA:  CLRF   x72
05FC:  MOVWF  x71
05FE:  MOVLW  02
0600:  ADDWF  x71,W
0602:  MOVWF  01
0604:  MOVLW  00
0606:  ADDWFC x72,W
0608:  MOVWF  03
060A:  MOVFF  01,FE9
060E:  MOVLW  04
0610:  ADDWF  03,W
0612:  MOVWF  FEA
0614:  MOVFF  6C,FEC
0618:  MOVF   FED,F
061A:  MOVFF  6B,FEF
....................             addy += usb_ep_rx_size[en]; 
061E:  BCF    FD8.0
0620:  RLCF   x6A,W
0622:  CLRF   03
0624:  MOVFF  FF2,71
0628:  BCF    FF2.7
062A:  RCALL  00DA
062C:  TBLRD*+
062E:  MOVFF  FF5,03
0632:  BTFSC  x71.7
0634:  BSF    FF2.7
0636:  ADDWF  x6B,F
0638:  MOVF   03,W
063A:  ADDWFC x6C,F
....................            #if USB_IGNORE_RX_DTS 
....................             i = 0x80; 
....................            #else 
....................             i = 0x88; 
063C:  MOVLW  88
063E:  MOVWF  x70
....................            #endif 
....................             if (bit_test(len,8)) {bit_set(i,0);} 
0640:  BTFSS  x6F.0
0642:  BRA    0646
0644:  BSF    x70.0
....................             if (bit_test(len,9)) {bit_set(i,1);} 
0646:  BTFSS  x6F.1
0648:  BRA    064C
064A:  BSF    x70.1
....................             EP_BDxST_O(en) = i; 
064C:  MOVF   x6A,W
064E:  MULLW  08
0650:  MOVF   FF3,W
0652:  CLRF   x72
0654:  MOVWF  FE9
0656:  MOVLW  04
0658:  ADDWF  x72,W
065A:  MOVWF  FEA
065C:  MOVFF  70,FEF
....................          } 
....................          if (usb_ep_tx_type[en] != USB_ENABLE_DISABLED)  
0660:  CLRF   03
0662:  MOVF   x6A,W
0664:  MOVFF  FF2,71
0668:  BCF    FF2.7
066A:  RCALL  00BA
066C:  BTFSC  x71.7
066E:  BSF    FF2.7
0670:  SUBLW  FF
0672:  BZ    06E6
....................          { 
....................             new_uep |= 0x02; 
0674:  BSF    x6D.1
....................             EP_BDxADR_I(en) = addy; 
0676:  MOVF   x6A,W
0678:  MULLW  08
067A:  MOVF   FF3,W
067C:  CLRF   x72
067E:  MOVWF  x71
0680:  MOVLW  04
0682:  ADDWF  x71,F
0684:  MOVLW  00
0686:  ADDWFC x72,F
0688:  MOVLW  02
068A:  ADDWF  x71,W
068C:  MOVWF  01
068E:  MOVLW  00
0690:  ADDWFC x72,W
0692:  MOVWF  03
0694:  MOVFF  01,FE9
0698:  MOVLW  04
069A:  ADDWF  03,W
069C:  MOVWF  FEA
069E:  MOVFF  6C,FEC
06A2:  MOVF   FED,F
06A4:  MOVFF  6B,FEF
....................             addy += usb_ep_tx_size[en]; 
06A8:  BCF    FD8.0
06AA:  RLCF   x6A,W
06AC:  CLRF   03
06AE:  MOVFF  FF2,71
06B2:  BCF    FF2.7
06B4:  RCALL  00DA
06B6:  TBLRD*+
06B8:  MOVFF  FF5,03
06BC:  BTFSC  x71.7
06BE:  BSF    FF2.7
06C0:  ADDWF  x6B,F
06C2:  MOVF   03,W
06C4:  ADDWFC x6C,F
....................             EP_BDxST_I(en) = 0x40; 
06C6:  MOVF   x6A,W
06C8:  MULLW  08
06CA:  MOVF   FF3,W
06CC:  CLRF   x72
06CE:  MOVWF  x71
06D0:  MOVLW  04
06D2:  ADDWF  x71,F
06D4:  MOVLW  00
06D6:  ADDWFC x72,F
06D8:  MOVFF  71,FE9
06DC:  MOVLW  04
06DE:  ADDWF  x72,W
06E0:  MOVWF  FEA
06E2:  MOVLW  40
06E4:  MOVWF  FEF
....................          } 
....................          if (new_uep == 0x06) {new_uep = 0x0E;} 
06E6:  MOVF   x6D,W
06E8:  SUBLW  06
06EA:  BNZ   06F0
06EC:  MOVLW  0E
06EE:  MOVWF  x6D
....................          if (usb_ep_tx_type[en] != USB_ENABLE_ISOCHRONOUS) {new_uep |= 0x10;} 
06F0:  CLRF   03
06F2:  MOVF   x6A,W
06F4:  MOVFF  FF2,71
06F8:  BCF    FF2.7
06FA:  RCALL  00BA
06FC:  BTFSC  x71.7
06FE:  BSF    FF2.7
0700:  SUBLW  01
0702:  BZ    0706
0704:  BSF    x6D.4
....................           
....................          UEP(en) = new_uep; 
0706:  CLRF   03
0708:  MOVF   x6A,W
070A:  ADDLW  70
070C:  MOVWF  FE9
070E:  MOVLW  0F
0710:  ADDWFC 03,W
0712:  MOVWF  FEA
0714:  MOVFF  6D,FEF
0718:  INCF   x6A,F
071A:  BRA    058A
....................       } 
....................    } 
071C:  GOTO   07BA (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoint(unsigned int8 en)  
.................... { 
....................    UEP(en) = ENDPT_DISABLED; 
*
02B0:  CLRF   03
02B2:  MOVF   x72,W
02B4:  ADDLW  70
02B6:  MOVWF  FE9
02B8:  MOVLW  0F
02BA:  ADDWFC 03,W
02BC:  MOVWF  FEA
02BE:  CLRF   FEF
....................     
....................    if (usb_endpoint_is_valid(en)) 
02C0:  MOVFF  72,73
02C4:  RCALL  025A
02C6:  MOVF   01,F
02C8:  BZ    02FA
....................    { 
....................       EP_BDxST_O(en) = 0;   //clear state, deque if necessary       
02CA:  MOVF   x72,W
02CC:  MULLW  08
02CE:  MOVF   FF3,W
02D0:  CLRF   x74
02D2:  MOVWF  FE9
02D4:  MOVLW  04
02D6:  ADDWF  x74,W
02D8:  MOVWF  FEA
02DA:  CLRF   FEF
....................       EP_BDxST_I(en) = 0;   //clear state, deque if necessary 
02DC:  MOVF   x72,W
02DE:  MULLW  08
02E0:  MOVF   FF3,W
02E2:  CLRF   x74
02E4:  MOVWF  x73
02E6:  MOVLW  04
02E8:  ADDWF  x73,F
02EA:  MOVLW  00
02EC:  ADDWFC x74,F
02EE:  MOVFF  73,FE9
02F2:  MOVLW  04
02F4:  ADDWF  x74,W
02F6:  MOVWF  FEA
02F8:  CLRF   FEF
....................    } 
02FA:  RETURN 0
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_disable_endpoints(void)  
.................... { 
....................    unsigned int8 i; 
....................     
....................    for (i=1; i<USB_NUM_UEP; i++) 
02FC:  MOVLW  01
02FE:  MOVWF  x71
0300:  MOVF   x71,W
0302:  SUBLW  0F
0304:  BNC   0310
....................       usb_disable_endpoint(i); 
0306:  MOVFF  71,72
030A:  RCALL  02B0
030C:  INCF   x71,F
030E:  BRA    0300
0310:  RETURN 0
....................        
....................    //__usb_kbhit_status=0; 
.................... } 
....................  
.................... /// END Hardware layer functions required by USB.C 
....................  
....................  
.................... /// BEGIN USB Interrupt Service Routine 
....................  
.................... static void usb_clear_trn(void) 
.................... { 
....................    //UIR_TRN = 0; 
....................    //delay_cycles(6); 
....................    UIR &= ~(1 << BIT_TRN); 
*
0004:  BCF    F68.3
0006:  RETURN 0
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_handle_interrupt() 
.................... /* 
.................... /* Summary: Checks the interrupt, and acts upon event.  Processing finished 
.................... /*          tokens is the majority of this code, and is handled by usb.c 
.................... /* 
.................... /* NOTE: If you wish to change to a polling method (and not an interrupt  
.................... /*       method), then you must call this function rapidly.  If there is more  
.................... /*       than 10ms latency the PC may think the USB device is stalled and 
.................... /*       disable it. 
.................... /*       To switch to a polling method, remove the #int_usb line above this  
.................... /*       fuction.  Also, goto usb_init() and remove the code that enables the  
.................... /*       USB interrupt. 
.................... /******************************************************************************/ 
.................... #if !defined(USB_ISR_POLLING) && !defined(USB_NO_ISR_PREPROCESSOR) 
.................... #int_usb NOCLEAR 
.................... #endif 
.................... void usb_isr(void) 
.................... { 
....................    unsigned int8 TRNAttempts; 
....................     
....................    clear_interrupt(INT_USB); 
*
0CCC:  BCF    FA1.5
....................     
....................    if (usb_state == USB_STATE_DETACHED) return;   //should never happen, though 
0CCE:  MOVF   1F,F
0CD0:  BTFSC  FD8.2
0CD2:  BRA    0D3A
....................    if (UIR)  
0CD4:  MOVF   F68,F
0CD6:  BTFSC  FD8.2
0CD8:  BRA    0D3A
....................    { 
....................       debug_usb(debug_putc,"\r\n\n[%X] ",UIR); 
....................  
....................       //activity detected.  (only enable after sleep) 
....................       if (UIR_ACTV && UIE_ACTV) {usb_isr_activity();} 
0CDA:  BTFSS  F68.2
0CDC:  BRA    0CE4
0CDE:  BTFSC  F69.2
0CE0:  GOTO   0214
....................  
....................       if (UCON_SUSPND) return; 
0CE4:  BTFSC  F6D.1
0CE6:  BRA    0D3A
....................  
....................       if (UIR_STALL && UIE_STALL) {usb_isr_stall();}        //a stall handshake was sent 
0CE8:  BTFSS  F68.5
0CEA:  BRA    0CF2
0CEC:  BTFSC  F69.5
0CEE:  GOTO   0244
....................  
....................       if (UIR_UERR && UIE_UERR) {usb_isr_uerr();}          //error has been detected 
0CF2:  BTFSS  F68.1
0CF4:  BRA    0CFC
0CF6:  BTFSC  F69.1
0CF8:  GOTO   0252
....................  
....................       if (UIR_URST && UIE_URST) {usb_isr_rst();}        //usb reset has been detected 
0CFC:  BTFSS  F68.0
0CFE:  BRA    0D06
0D00:  BTFSC  F69.0
0D02:  GOTO   033A
....................  
....................       if (UIR_IDLE && UIE_IDLE) {usb_isr_uidle();}        //idle time, we can go to sleep 
0D06:  BTFSS  F68.4
0D08:  BRA    0D10
0D0A:  BTFSC  F69.4
0D0C:  GOTO   0364
....................        
....................       if (UIR_SOF && UIE_SOF) {usb_isr_sof();} 
0D10:  BTFSS  F68.6
0D12:  BRA    0D1A
0D14:  BTFSC  F69.6
0D16:  GOTO   036E
....................  
....................       TRNAttempts = 0; 
0D1A:  CLRF   x66
....................       do 
....................       { 
....................          if (UIR_TRN && UIE_TRN)  
0D1C:  BTFSS  F68.3
0D1E:  BRA    0D30
0D20:  BTFSS  F69.3
0D22:  BRA    0D30
....................          { 
....................             USTATCopy = U1STAT; 
0D24:  MOVFF  F6C,1E
....................             usb_clear_trn(); 
0D28:  CALL   0004
....................             usb_isr_tok_dne(); 
0D2C:  BRA    0C02
....................          } 
0D2E:  BRA    0D32
....................          else 
....................             break; 
0D30:  BRA    0D3A
....................       } while (TRNAttempts++ < 4); 
0D32:  MOVF   x66,W
0D34:  INCF   x66,F
0D36:  SUBLW  03
0D38:  BC    0D1C
....................  
....................      #if defined(USB_CDC_ISR) 
....................       //has to be done here, can't be done until TRN is empty. 
....................       if (usb_cdc_kbhit()) 
....................       { 
....................          USB_CDC_ISR(); 
....................       } 
....................      #endif 
....................    } 
0D3A:  GOTO   0078
.................... } 
....................  
.................... // SOF interrupt not handled.  user must add this depending on application 
.................... void usb_isr_sof(void)  
.................... { 
....................    debug_usb(debug_putc, "\r\nSOF"); 
....................     
....................    //UIR_SOF = 0; 
....................    UIR &= ~(1 << BIT_SOF); 
*
036E:  BCF    F68.6
0370:  GOTO   0D1A (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_rst() 
.................... /* 
.................... /* Summary: The host (computer) sent us a RESET command.  Reset USB device 
.................... /*          and token handler code to initial state. 
.................... /* 
.................... /******************************************************************************/ 
.................... void usb_isr_rst(void)  
.................... { 
....................    debug_usb(debug_putc,"R"); 
....................  
....................    UEIR = 0; 
*
033A:  CLRF   F6A
....................    UIR = 0; 
033C:  CLRF   F68
....................    UEIE = 0x9F; 
033E:  MOVLW  9F
0340:  MOVWF  F6B
....................    UIE = STANDARD_INTS & ~__USB_UIF_ACTIVE; 
0342:  MOVLW  3D
0344:  MOVWF  F69
....................  
....................    UADDR = 0; 
0346:  CLRF   F6E
....................  
....................    usb_disable_endpoints(); 
0348:  RCALL  02FC
....................     
....................    usb_token_reset(); 
034A:  RCALL  0312
....................  
....................    UEP(0) = ENDPT_CONTROL | 0x10; 
034C:  MOVLW  16
034E:  MOVWF  F70
....................  
....................    while (UIR_TRN)  
0350:  BTFSS  F68.3
0352:  BRA    0358
....................    { 
....................       usb_clear_trn(); 
0354:  RCALL  0004
0356:  BRA    0350
....................    } 
....................  
....................    UCON_PKTDIS = 0; //SIE token and packet processing enabled 
0358:  BCF    F6D.4
....................  
....................    usb_init_ep0_setup(); 
035A:  RCALL  0224
....................  
....................    usb_state = USB_STATE_DEFAULT; //put usb mcu into default state 
035C:  MOVLW  03
035E:  MOVWF  1F
0360:  GOTO   0D06 (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_ep0_setup() 
.................... /* 
.................... /* Summary: Configure EP0 to receive setup packets 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_ep0_setup(void)  
.................... { 
....................     EP_BDxCNT_O(0) = USB_MAX_EP0_PACKET_LENGTH; 
*
0224:  MOVLW  40
0226:  MOVLB  4
0228:  MOVWF  x01
....................     EP_BDxADR_O(0) = USB_DATA_BUFFER_LOCATION; 
022A:  MOVLW  04
022C:  MOVWF  x03
022E:  MOVLW  10
0230:  MOVWF  x02
....................    #if USB_IGNORE_RX_DTS 
....................     EP_BDxST_O(0) = 0x80; //give control to SIE, data toggle synch off 
....................    #else 
....................     EP_BDxST_O(0) = 0x88; //give control to SIE, DATA0, data toggle synch on 
0232:  MOVLW  88
0234:  MOVWF  x00
....................    #endif 
....................  
....................     EP_BDxST_I(0) = 0; 
0236:  CLRF   x04
....................     EP_BDxADR_I(0) = USB_DATA_BUFFER_LOCATION + (int16)USB_MAX_EP0_PACKET_LENGTH; 
0238:  MOVLW  04
023A:  MOVWF  x07
023C:  MOVLW  50
023E:  MOVWF  x06
0240:  MOVLB  0
0242:  RETURN 0
.................... } 
....................  
.................... /******************************************************************************* 
.................... /* usb_isr_uerr() 
.................... /* 
.................... /* Summary: The USB peripheral had an error.  If user specified, error counter 
.................... /*          will incerement.  If having problems check the status of these 8 bytes. 
.................... /* 
.................... /* NOTE: This code is not enabled by default. 
.................... /********************************************************************************/ 
.................... void usb_isr_uerr(void) 
.................... { 
....................   #if USB_USE_ERROR_COUNTER 
....................    int ints; 
....................   #endif 
....................  
....................    debug_usb(debug_putc,"E %X ",UEIR); 
....................  
....................   #if USB_USE_ERROR_COUNTER 
....................    ints=UEIR & UEIE; //mask off the flags with the ones that are enabled 
....................  
....................    if ( bit_test(ints,0) )  
....................    {  
....................       //increment pid_error counter 
....................       debug_usb(debug_putc,"PID "); 
....................       ERROR_COUNTER[0]++; 
....................    } 
....................  
....................    if ( bit_test(ints,1) )  
....................    {   
....................       //increment crc5 error counter 
....................       debug_usb(debug_putc,"CRC5 "); 
....................       ERROR_COUNTER[1]++; 
....................    } 
....................  
....................    if ( bit_test(ints,2) )  
....................    { 
....................       //increment crc16 error counter 
....................       debug_usb(debug_putc,"CRC16 "); 
....................       ERROR_COUNTER[2]++; 
....................    } 
....................  
....................    if ( bit_test(ints,3) )  
....................    {   
....................       //increment dfn8 error counter 
....................       debug_usb(debug_putc,"DFN8 "); 
....................       ERROR_COUNTER[3]++; 
....................    } 
....................  
....................    if ( bit_test(ints,4) )  
....................    {   
....................       //increment bto error counter 
....................       debug_usb(debug_putc,"BTO "); 
....................       ERROR_COUNTER[4]++; 
....................    } 
....................  
....................    if ( bit_test(ints,7) )  
....................    {  
....................       //increment bts error counter 
....................       debug_usb(debug_putc,"BTS "); 
....................       ERROR_COUNTER[5]++; 
....................    } 
....................   #endif 
....................  
....................    UEIR = 0; 
*
0252:  CLRF   F6A
....................     
....................    //UIR_UERR = 0; 
....................    UIR &= ~(1 << BIT_UERR); 
0254:  BCF    F68.1
0256:  GOTO   0CFC (RETURN)
.................... } 
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_uidle() 
.................... /* 
.................... /* Summary: USB peripheral detected IDLE.  Put the USB peripheral to sleep. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_uidle(void) 
.................... { 
....................    debug_usb(debug_putc, "I"); 
....................  
....................    UIE_ACTV = 1;   //enable activity interrupt flag. (we are now suspended until we get an activity interrupt. nice) 
*
0364:  BSF    F69.2
....................     
....................    //UIR_IDLE = 0; //clear idle interrupt flag 
....................    UIR &= ~(1 << BIT_IDLE); 
0366:  BCF    F68.4
....................     
....................    UCON_SUSPND = 1; //set suspend. we are now suspended 
0368:  BSF    F6D.1
036A:  GOTO   0D10 (RETURN)
.................... } 
....................  
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_activity() 
.................... /* 
.................... /* Summary: USB peripheral detected activity on the USB device.  Wake-up the USB 
.................... /*          peripheral. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_activity(void) 
.................... { 
....................    debug_usb(debug_putc, "A"); 
....................  
....................    UCON_SUSPND = 0; //turn off low power suspending 
*
0214:  BCF    F6D.1
....................    UIE_ACTV = 0; //clear activity interupt enabling 
0216:  BCF    F69.2
....................     
....................    while(UIR_ACTV) 
0218:  BTFSS  F68.2
021A:  BRA    0220
....................    { 
....................       //UIR_ACTV = 0; 
....................       UIR &= ~(1 << BIT_ACTV); 
021C:  BCF    F68.2
021E:  BRA    0218
....................    } 
0220:  GOTO   0CE4 (RETURN)
.................... } 
....................  
.................... /****************************************************************************** 
.................... /* usb_isr_stall() 
.................... /* 
.................... /* Summary: Stall handshake detected. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_stall(void)  
.................... { 
....................    debug_usb(debug_putc, "S"); 
....................     
....................     
....................    if (bit_test(UEP(0),0))  
*
0244:  BTFSS  F70.0
0246:  BRA    024C
....................    { 
....................       usb_init_ep0_setup(); 
0248:  RCALL  0224
....................       bit_clear(UEP(0), 0); 
024A:  BCF    F70.0
....................    } 
....................     
....................    //UIR_STALL = 0; 
....................    UIR &= ~(1 << BIT_STALL); 
024C:  BCF    F68.5
024E:  GOTO   0CF2 (RETURN)
.................... } 
....................  
.................... // see usb_hw_layer.h for documentation 
.................... void usb_request_send_response(unsigned int8 len) {__setup_0_tx_size = len;} 
*
0374:  MOVFF  6C,20
0378:  RETURN 0
.................... void usb_request_get_data(void)  {__setup_0_tx_size = 0xFE;} 
.................... void usb_request_stall(void)  {__setup_0_tx_size = 0xFF;} 
037A:  SETF   20
037C:  RETURN 0
....................  
.................... /***************************************************************************** 
.................... /* usb_isr_tok_dne() 
.................... /* 
.................... /* Summary: A Token (IN/OUT/SETUP) has been received by the USB peripheral. 
.................... /*          If a setup token on EP0 was received, run the chapter 9 code and 
.................... /*          handle the request. 
.................... /*          If an IN token on EP0 was received, continue transmitting any 
.................... /*          unfinished requests that may take more than one packet to transmit 
.................... /*          (if necessary). 
.................... /*          If an OUT token on any other EP was received, mark that EP as ready 
.................... /*          for a usb_get_packet(). 
.................... /*          Does not handle any IN or OUT tokens on EP0. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_isr_tok_dne(void)  
.................... { 
....................    unsigned int8 en; 
....................  
....................    en = USTATCopy>>3; 
*
0C02:  RRCF   1E,W
0C04:  MOVWF  x67
0C06:  RRCF   x67,F
0C08:  RRCF   x67,F
0C0A:  MOVLW  1F
0C0C:  ANDWF  x67,F
....................  
....................    debug_usb(debug_putc, "T "); 
....................    debug_usb(debug_putc, "%X ", USTATCopy); 
....................  
....................    if (USTATCopy == USTAT_OUT_SETUP_E0)  
0C0E:  MOVF   1E,F
0C10:  BNZ   0C94
....................    { 
....................       //new out or setup token in the buffer 
....................       int8 pidKey; 
....................        
....................       debug_usb(debug_putc,"%X ", EP_BDxST_O(0)); 
....................        
....................       pidKey = EP_BDxST_O(0) & 0x3C;  //save PID 
0C12:  MOVLB  4
0C14:  MOVF   x00,W
0C16:  ANDLW  3C
0C18:  MOVLB  0
0C1A:  MOVWF  x68
....................        
....................       EP_BDxST_O(0) &= 0x43;  //clear pid, prevent bdstal/pid confusion 
0C1C:  MOVLW  43
0C1E:  MOVLB  4
0C20:  ANDWF  x00,F
....................        
....................       if (pidKey == USB_PIC_PID_SETUP)  
0C22:  MOVLB  0
0C24:  MOVF   x68,W
0C26:  SUBLW  34
0C28:  BNZ   0C66
....................       { 
....................          if ((EP_BDxST_I(0) & 0x80) != 0x00) 
0C2A:  MOVLB  4
0C2C:  MOVF   x04,W
0C2E:  ANDLW  80
0C30:  BZ    0C34
....................             EP_BDxST_I(0)=0;   // return the in buffer to us (dequeue any pending requests) 
0C32:  CLRF   x04
....................  
....................          debug_usb(debug_putc,"(%U) ", EP_BDxCNT_O(0)); 
....................          debug_display_ram(EP_BDxCNT_O(0), usb_ep0_rx_buffer); 
....................  
....................          usb_isr_tok_setup_dne(); 
0C34:  MOVLB  0
0C36:  BRA    09B2
....................  
....................          UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
0C38:  BCF    F6D.4
....................  
....................          //if setup_0_tx_size==0xFF - stall ep0 (unhandled request) (see usb_request_stall()) 
....................          //if setup_0_tx_size==0xFE - get EP0OUT ready for a data packet, leave EP0IN alone (see usb_request_get_data()) 
....................          //else setup_0_tx_size=size of response, get EP0OUT ready for a setup packet, mark EPOIN ready for transmit (see usb_request_send_response()) 
....................          if (__setup_0_tx_size == 0xFF) 
0C3A:  INCFSZ 20,W
0C3C:  BRA    0C48
....................             usb_flush_out(0, USB_DTS_STALL); 
0C3E:  CLRF   x69
0C40:  MOVLW  03
0C42:  MOVWF  x6A
0C44:  RCALL  09E4
0C46:  BRA    0C64
....................          else  
....................          { 
....................             usb_flush_out(0, USB_DTS_TOGGLE); 
0C48:  CLRF   x69
0C4A:  MOVLW  02
0C4C:  MOVWF  x6A
0C4E:  RCALL  09E4
....................             if (__setup_0_tx_size != 0xFE) 
0C50:  MOVF   20,W
0C52:  SUBLW  FE
0C54:  BZ    0C64
....................                usb_flush_in(0 ,__setup_0_tx_size, USB_DTS_USERX); 
0C56:  CLRF   x69
0C58:  CLRF   x6B
0C5A:  MOVFF  20,6A
0C5E:  MOVLW  04
0C60:  MOVWF  x6C
0C62:  RCALL  0AEA
....................          } 
....................          //why was this here? 
....................          //UCON_PKTDIS=0;       // UCON,PKT_DIS ; Assuming there is nothing to dequeue, clear the packet disable bit 
....................       } 
0C64:  BRA    0C92
....................       else if (pidKey == USB_PIC_PID_OUT)  
0C66:  MOVF   x68,W
0C68:  SUBLW  04
0C6A:  BNZ   0C92
....................       { 
....................          usb_isr_tok_out_dne(0); 
0C6C:  CLRF   x69
0C6E:  RCALL  0BC0
....................          usb_flush_out(0, USB_DTS_TOGGLE); 
0C70:  CLRF   x69
0C72:  MOVLW  02
0C74:  MOVWF  x6A
0C76:  RCALL  09E4
....................          if ((__setup_0_tx_size!=0xFE) && (__setup_0_tx_size!=0xFF)) 
0C78:  MOVF   20,W
0C7A:  SUBLW  FE
0C7C:  BZ    0C92
0C7E:  INCFSZ 20,W
0C80:  BRA    0C84
0C82:  BRA    0C92
....................          { 
....................             usb_flush_in(0,__setup_0_tx_size,USB_DTS_DATA1);   //send response (usually a 0len) 
0C84:  CLRF   x69
0C86:  CLRF   x6B
0C88:  MOVFF  20,6A
0C8C:  MOVLW  01
0C8E:  MOVWF  x6C
0C90:  RCALL  0AEA
....................          } 
....................       } 
....................       else 
....................       { 
....................          debug_usb(debug_putc, "!!! "); 
....................       } 
....................    } 
0C92:  BRA    0CC8
....................    else if (USTATCopy == USTAT_IN_E0)  
0C94:  MOVF   1E,W
0C96:  SUBLW  04
0C98:  BNZ   0CB6
....................    {    
....................       //pic -> host transfer completed 
....................       //EP_BDxST_I(0) = EP_BDxST_I(0) & 0xC3;   //clear up any BDSTAL confusion 
....................       __setup_0_tx_size = 0xFF; 
0C9A:  SETF   20
....................       usb_isr_tok_in_dne(0); 
0C9C:  CLRF   x69
0C9E:  RCALL  0BEA
....................       if (__setup_0_tx_size!=0xFF) 
0CA0:  INCFSZ 20,W
0CA2:  BRA    0CA6
0CA4:  BRA    0CB4
....................          usb_flush_in(0, __setup_0_tx_size, USB_DTS_TOGGLE); 
0CA6:  CLRF   x69
0CA8:  CLRF   x6B
0CAA:  MOVFF  20,6A
0CAE:  MOVLW  02
0CB0:  MOVWF  x6C
0CB2:  RCALL  0AEA
....................       else 
....................       { 
....................          //usb_init_ep0_setup(); //REMOVED JUN/9/2009 
....................       }   
....................    } 
0CB4:  BRA    0CC8
....................    else  
....................    { 
....................       if (!bit_test(USTATCopy, 2))  
0CB6:  BTFSC  1E.2
0CB8:  BRA    0CC2
....................       { 
....................          //EP_BDxST_O(en) = EP_BDxST_O(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_out_dne(en); 
0CBA:  MOVFF  67,69
0CBE:  RCALL  0BC0
....................       } 
0CC0:  BRA    0CC8
....................       else  
....................       { 
....................          //EP_BDxST_I(en) = EP_BDxST_I(en) & 0xC3;   //clear up any BDSTAL confusion 
....................          usb_isr_tok_in_dne(en); 
0CC2:  MOVFF  67,69
0CC6:  RCALL  0BEA
....................       } 
....................    } 
0CC8:  GOTO   0D2E (RETURN)
.................... } 
....................  
.................... /// END USB Interrupt Service Routine 
....................  
.................... #ENDIF 
....................  
.................... #endif 
....................  
.................... #if defined(__PIC24_USB_H__) 
....................  #include <pic24_usb.c> 
.................... #endif 
....................  
.................... #if defined(__USBN960X_H__) 
....................  #include <usbn960x.c> 
.................... #endif 
....................  
....................  
.................... #IFNDEF __USB_HARDWARE__ 
....................    #ERROR You must include USB hardware driver. 
.................... #ENDIF 
....................  
.................... #IFNDEF __USB_DESCRIPTORS__ 
....................    #ERROR You must include USB descriptors. 
.................... #ENDIF 
....................  
.................... #if (defined(USB_USE_FULL_SPEED) && (USB_USE_FULL_SPEED==1)) 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  64 
.................... #else 
....................    #define USB_ISO_PACKET_MAX_SIZE     1023 
....................    #define USB_NONISO_PACKET_MAX_SIZE  8 
.................... #endif 
....................  
.................... //--------- endpoint 1 defines ---------- 
.................... #if USB_EP1_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif 
.................... #endif 
....................  
.................... #if USB_EP1_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP1_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP1_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP1_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 2 defines ---------- 
.................... #if USB_EP2_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP2_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP2_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP2_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP2_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 3 defines ---------- 
.................... #if USB_EP3_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP3_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP3_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP3_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP3_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 4 defines ---------- 
.................... #if USB_EP4_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP4_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP4_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP4_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP4_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 5 defines ---------- 
.................... #if USB_EP5_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP5_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP5_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP5_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP5_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 6 defines ---------- 
.................... #if USB_EP6_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP6_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP6_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP6_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP6_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 7 defines ---------- 
.................... #if USB_EP7_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP7_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP7_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP7_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP7_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 8 defines ---------- 
.................... #if USB_EP8_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP8_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP8_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP8_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP8_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 9 defines ---------- 
.................... #if USB_EP9_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP9_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP9_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP9_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP9_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 10 defines ---------- 
.................... #if USB_EP10_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP10_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP10_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP10_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP10_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 11 defines ---------- 
.................... #if USB_EP11_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP11_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP11_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP11_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP11_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 12 defines ---------- 
.................... #if USB_EP12_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP12_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP12_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP12_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP12_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
....................  
.................... //--------- endpoint 13 defines ---------- 
.................... #if USB_EP13_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... #if USB_EP13_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP13_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP13_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP13_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
....................  
.................... //--------- endpoint 14 defines ---------- 
.................... #if USB_EP14_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif  
.................... #endif 
....................  
.................... #if USB_EP14_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP14_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP14_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP14_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
....................  
.................... //--------- endpoint 15 defines ---------- 
.................... #if USB_EP15_RX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_RX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_RX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_RX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif   
.................... #endif 
....................  
.................... #if USB_EP15_TX_ENABLE!=USB_ENABLE_DISABLED 
....................  #if (((USB_EP15_TX_ENABLE==USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_ISO_PACKET_MAX_SIZE)) || \ 
....................       ((USB_EP15_TX_ENABLE!=USB_ENDPOINT_TYPE_ISOCHRONOUS) &&   \ 
....................       (USB_EP15_TX_SIZE > USB_NONISO_PACKET_MAX_SIZE))) 
....................    #error Packet size is too big 
....................  #endif    
.................... #endif 
....................  
.................... TYPE_USB_STACK_STATUS USB_stack_status; 
....................  
.................... unsigned int8 USB_address_pending;                        //save previous state because packets can take several isrs 
.................... unsigned int16 usb_getdesc_ptr; unsigned int16 usb_getdesc_len;             //for reading string and config descriptors 
....................  
.................... #IF USB_HID_BOOT_PROTOCOL 
.................... unsigned int8 hid_protocol[USB_NUM_HID_INTERFACES]; 
.................... #ENDIF 
....................  
.................... void usb_put_0len_0(void); 
.................... void usb_match_registers(int8 endpoint, int16 *status, int16 *buffer, int8 *size); 
....................  
.................... void usb_isr_tkn_setup_StandardEndpoint(void); 
.................... void usb_isr_tkn_setup_StandardDevice(void); 
.................... void usb_isr_tkn_setup_StandardInterface(void); 
.................... #IF USB_HID_DEVICE 
....................    void usb_isr_tkn_setup_ClassInterface(void); 
.................... #ENDIF 
.................... void usb_Get_Descriptor(void); 
.................... void usb_copy_desc_seg_to_ep(void); 
.................... void usb_finish_set_address(void); 
....................  
.................... int8 USB_Interface[USB_MAX_NUM_INTERFACES];              //config state for all of our interfaces, NUM_INTERFACES defined with descriptors 
....................  
.................... /// BEGIN User Functions 
....................  
.................... // see usb.h for documentation 
.................... int1 usb_enumerated(void) 
.................... { 
....................    return(USB_stack_status.curr_config); 
*
1118:  MOVF   18,W
111A:  MOVWF  01
111C:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_wait_for_enumeration(void)  
.................... { 
....................    while (USB_stack_status.curr_config == 0) {restart_wdt();} 
.................... } 
....................  
.................... // see USB.H for documentation 
.................... int1 usb_puts(unsigned int8 endpoint, int8 * ptr, unsigned int16 len, unsigned int8 timeout) { 
....................    unsigned int16 i=0; 
....................    int1 res; 
....................    unsigned int16 this_packet_len; 
....................    unsigned int16 packet_size; 
....................    unsigned int32 timeout_1us; 
....................  
....................    packet_size = usb_ep_tx_size[endpoint]; 
....................     
....................    //printf("\r\nUSB PUTS %U LEN=%LU MAX_PACK=%LU\r\n", endpoint, len, packet_size); 
....................  
....................    //send data packets until timeout or no more packets to send 
....................    while (i < len)  
....................    { 
....................       timeout_1us = (int32)timeout*1000; 
....................       if ((len - i) > packet_size) {this_packet_len = packet_size;} 
....................       else {this_packet_len = len-i;} 
....................       //putc('*'); 
....................       do  
....................       { 
....................          res = usb_put_packet(endpoint, ptr + i, this_packet_len, USB_DTS_TOGGLE);   //send 64 byte packets 
....................          //putc('.'); 
....................          if (!res) 
....................          { 
....................             delay_us(1); 
....................             //delay_ms(500); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................       i += packet_size; 
....................    } 
....................  
....................  
....................    //send 0len packet if needed 
....................    if (i==len) { 
....................       timeout_1us=(int32)timeout*1000; 
....................       do { 
....................          res = usb_put_packet(endpoint,0,0,USB_DTS_TOGGLE);   //indicate end of message 
....................          if (!res) { 
....................             delay_us(1); 
....................             timeout_1us--; 
....................          } 
....................       } while (!res && (!timeout || timeout_1us)); 
....................    } 
....................  
....................    return(res); 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... unsigned int16 usb_gets(unsigned int8 endpoint, int8 * ptr, unsigned int16 max, unsigned int16 timeout) { 
....................    unsigned int16 ret=0; 
....................    unsigned int16 to; 
....................    unsigned int16 len; 
....................    unsigned int16 packet_size; 
....................    unsigned int16 this_packet_max; 
....................  
....................    packet_size=usb_ep_rx_size[endpoint]; 
....................  
....................    do { 
....................       if (packet_size < max) {this_packet_max=packet_size;} else {this_packet_max=max;} 
....................       to=0; 
....................       do { 
....................          if (usb_kbhit(endpoint)) { 
....................             len=usb_get_packet(endpoint,ptr,this_packet_max); 
....................             ptr+=len; 
....................             max-=len; 
....................             ret+=len; 
....................             break; 
....................          } 
....................          else { 
....................             to++; 
....................             delay_ms(1); 
....................          } 
....................       } while (to!=timeout); 
....................    } while ((len == packet_size) && (!timeout || (to!=timeout)) && max); 
....................  
....................    return(ret); 
.................... } 
....................  
.................... /// END User Functions 
....................  
....................  
.................... /// BEGIN USB Token, standard and HID request handler (part of ISR) 
....................  
.................... // see usb.h for documentation 
.................... void usb_token_reset(void)  
.................... { 
....................    unsigned int i; 
....................  
....................    usb_getdesc_len = 0; 
*
0312:  CLRF   25
0314:  CLRF   24
....................     
....................    for (i=0;i<USB_MAX_NUM_INTERFACES;i++)  
0316:  CLRF   x67
0318:  MOVF   x67,F
031A:  BNZ   0330
....................       USB_Interface[i] = 0;   //reset each interface to default 
031C:  CLRF   03
031E:  MOVF   x67,W
0320:  ADDLW  26
0322:  MOVWF  FE9
0324:  MOVLW  00
0326:  ADDWFC 03,W
0328:  MOVWF  FEA
032A:  CLRF   FEF
....................  
....................   #IF USB_HID_BOOT_PROTOCOL 
....................    for (i=0;i<USB_NUM_HID_INTERFACES; i++) 
....................       hid_protocol[i] = 1; 
....................   #endif 
....................  
....................   #if USB_CDC_DEVICE 
032C:  INCF   x67,F
032E:  BRA    0318
....................    usb_cdc_init(); 
....................   #endif 
....................  
....................    USB_stack_status.curr_config = 0;      //unconfigured device 
0330:  CLRF   18
....................  
....................    USB_stack_status.status_device = 1;    //previous state.  init at none 
0332:  MOVLW  01
0334:  MOVWF  19
....................    USB_stack_status.dev_req = NONE;       //previous token request state.  init at none 
0336:  CLRF   17
0338:  RETURN 0
.................... } 
....................  
.................... //send a 0len packet to endpoint 0 (optimization) 
.................... //notice that this doesnt return the status 
.................... #define usb_put_0len_0() usb_request_send_response(0) 
....................  
.................... /************************************************************** 
.................... /* usb_endpoint_is_valid(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check. 
.................... /*                   bit 7 is direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: TRUE if endpoint is valid, FALSE if not 
.................... /* 
.................... /* Summary: Checks the dynamic configuration to see if requested 
.................... /*          endpoint is a valid endpoint. 
.................... /***************************************************************/ 
.................... int1 usb_endpoint_is_valid(unsigned int8 endpoint)  
.................... { 
....................    int1 direction; 
....................     
....................    direction = bit_test(endpoint,7); 
*
025A:  BCF    x74.0
025C:  BTFSC  x73.7
025E:  BSF    x74.0
....................     
....................    endpoint &= 0x7F; 
0260:  BCF    x73.7
....................     
....................    if (endpoint > 16) 
0262:  MOVF   x73,W
0264:  SUBLW  10
0266:  BC    026E
....................       return(FALSE); 
0268:  MOVLW  00
026A:  MOVWF  01
026C:  BRA    02AE
....................     
....................    if (direction) { //IN 
026E:  BTFSS  x74.0
0270:  BRA    0292
....................       return(usb_ep_tx_type[endpoint] != USB_ENABLE_DISABLED); 
0272:  CLRF   03
0274:  MOVF   x73,W
0276:  MOVFF  FF2,75
027A:  BCF    FF2.7
027C:  RCALL  00BA
027E:  BTFSC  x75.7
0280:  BSF    FF2.7
0282:  SUBLW  FF
0284:  BNZ   028A
0286:  MOVLW  00
0288:  BRA    028C
028A:  MOVLW  01
028C:  MOVWF  01
028E:  BRA    02AE
....................    } 
0290:  BRA    02AE
....................    else {   //OUT 
....................       return(usb_ep_rx_type[endpoint] != USB_ENABLE_DISABLED); 
0292:  CLRF   03
0294:  MOVF   x73,W
0296:  MOVFF  FF2,75
029A:  BCF    FF2.7
029C:  RCALL  00BA
029E:  BTFSC  x75.7
02A0:  BSF    FF2.7
02A2:  SUBLW  FF
02A4:  BNZ   02AA
02A6:  MOVLW  00
02A8:  BRA    02AC
02AA:  MOVLW  01
02AC:  MOVWF  01
....................    } 
02AE:  RETURN 0
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_in_dne(unsigned int8 endpoint) { 
....................    if (endpoint==0) { 
*
0BEA:  MOVF   x69,F
0BEC:  BNZ   0C00
....................       if (USB_stack_status.dev_req == GET_DESCRIPTOR) {usb_copy_desc_seg_to_ep();} //check this, we are missing report descriptor? 
0BEE:  DECFSZ 17,W
0BF0:  BRA    0BF8
0BF2:  CALL   037E
0BF6:  BRA    0C00
....................       else if (USB_stack_status.dev_req == SET_ADDRESS) {usb_finish_set_address();} 
0BF8:  MOVF   17,W
0BFA:  SUBLW  02
0BFC:  BTFSC  FD8.2
0BFE:  BRA    0BDC
....................    } 
....................   #if USB_CDC_DEVICE 
0C00:  RETURN 0
....................   else if (endpoint==USB_CDC_DATA_IN_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_in_cdc_data_dne(); 
....................   } 
....................   #endif 
.................... } 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_out_dne(unsigned int8 endpoint) 
.................... { 
....................    //TODO: 
....................    if (endpoint==0) { 
*
0BC0:  MOVF   x69,F
0BC2:  BNZ   0BC4
....................      debug_usb(debug_putc,"TOUT 0 "); 
....................      #if USB_CDC_DEVICE 
....................       usb_isr_tok_out_cdc_control_dne(); 
....................      //#else   //REMOVED JUN/9/2009 
....................      //usb_init_ep0_setup(); 
....................      #endif 
....................    } 
....................   #if USB_CDC_DEVICE 
0BC4:  RETURN 0
....................    else if (endpoint==USB_CDC_DATA_OUT_ENDPOINT) { //see ex_usb_serial.c example and usb_cdc.h driver 
....................       usb_isr_tok_out_cdc_data_dne(); 
....................    } 
....................   #endif 
....................    //else { 
....................    //   bit_set(__usb_kbhit_status,endpoint); 
....................    //} 
.................... } 
....................  
....................  
.................... //---- process setup message stage -----------// 
....................  
.................... // see usb.h for documentation 
.................... void usb_isr_tok_setup_dne(void)  
.................... { 
....................    USB_stack_status.dev_req=NONE; // clear the device request.. 
*
09B2:  CLRF   17
....................  
....................    switch(usb_ep0_rx_buffer[0] & 0x7F) { 
09B4:  MOVLB  4
09B6:  MOVF   x10,W
09B8:  ANDLW  7F
09BA:  XORLW  00
09BC:  MOVLB  0
09BE:  BZ    09CE
09C0:  XORLW  01
09C2:  BZ    09D2
09C4:  XORLW  03
09C6:  BZ    09D6
09C8:  XORLW  23
09CA:  BZ    09DA
09CC:  BRA    09DE
....................  
....................       case 0x00:  //standard to device 
....................          debug_usb(debug_putc," d"); 
....................          usb_isr_tkn_setup_StandardDevice(); 
09CE:  BRA    0720
....................          break; 
09D0:  BRA    09E0
....................  
....................       case 0x01:  //standard to interface 
....................          debug_usb(debug_putc," i"); 
....................          usb_isr_tkn_setup_StandardInterface(); 
09D2:  BRA    07CA
....................          break; 
09D4:  BRA    09E0
....................  
....................       case 0x02:  //standard to endpoint 
....................          debug_usb(debug_putc," e"); 
....................          usb_isr_tkn_setup_StandardEndpoint(); 
09D6:  BRA    0948
....................          break; 
09D8:  BRA    09E0
....................           
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case 0x21:  //class specific request.  the only class this driver supports is HID 
....................          debug_usb(debug_putc, " class"); 
....................         #if USB_HID_DEVICE && USB_CDC_DEVICE 
....................          if (usb_ep0_rx_buffer[4] == USB_HID_INTERFACE) 
....................          { 
....................             usb_isr_tkn_setup_ClassInterface(); 
....................          } 
....................          else 
....................          { 
....................             usb_isr_tkn_cdc(); 
....................          } 
....................         #elif USB_HID_DEVICE 
....................          usb_isr_tkn_setup_ClassInterface(); 
09DA:  BRA    09A6
....................         #else 
....................          usb_isr_tkn_cdc(); 
....................         #endif 
....................          break; 
09DC:  BRA    09E0
.................... #endif 
....................  
....................  
....................       //TODO: IF YOU WANT VENDOR SPECIFC REQUEST SUPPORT YOU MUST ADD IT HERE 
....................  
....................       default: 
....................          usb_request_stall(); 
09DE:  RCALL  037A
....................          break; 
....................    } 
09E0:  GOTO   0C38 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardDevice() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Device request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardDevice(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
*
0720:  MOVLB  4
0722:  MOVF   x11,W
0724:  XORLW  00
0726:  MOVLB  0
0728:  BZ    0744
072A:  XORLW  01
072C:  BZ    0756
072E:  XORLW  02
0730:  BZ    0770
0732:  XORLW  06
0734:  BZ    0788
0736:  XORLW  03
0738:  BZ    0796
073A:  XORLW  0E
073C:  BZ    079A
073E:  XORLW  01
0740:  BZ    07A6
0742:  BRA    07C4
....................  
....................       case USB_STANDARD_REQUEST_GET_STATUS:  //0 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.status_device; 
0744:  MOVFF  19,450
....................             usb_ep0_tx_buffer[1]=0; 
0748:  MOVLB  4
074A:  CLRF   x51
....................             usb_request_send_response(2); 
074C:  MOVLW  02
074E:  MOVLB  0
0750:  MOVWF  x6C
0752:  RCALL  0374
....................             break; 
0754:  BRA    07C6
....................  
....................       case USB_STANDARD_REQUEST_CLEAR_FEATURE:  //1 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0756:  MOVLB  4
0758:  DECFSZ x12,W
075A:  BRA    076A
....................                debug_usb(debug_putc,"CF"); 
....................                USB_stack_status.status_device &= 1; 
075C:  MOVLW  01
075E:  ANDWF  19,F
....................                usb_put_0len_0(); 
0760:  MOVLB  0
0762:  CLRF   x6C
0764:  RCALL  0374
....................             } 
0766:  BRA    076E
0768:  MOVLB  4
....................             else 
....................                usb_request_stall(); 
076A:  MOVLB  0
076C:  RCALL  037A
....................             break; 
076E:  BRA    07C6
....................  
....................       case USB_STANDARD_REQUEST_SET_FEATURE: //3 
....................             if (usb_ep0_rx_buffer[2] == 1) { 
0770:  MOVLB  4
0772:  DECFSZ x12,W
0774:  BRA    0782
....................                debug_usb(debug_putc,"SF"); 
....................                USB_stack_status.status_device |= 2; 
0776:  BSF    19.1
....................                usb_put_0len_0(); 
0778:  MOVLB  0
077A:  CLRF   x6C
077C:  RCALL  0374
....................             } 
077E:  BRA    0786
0780:  MOVLB  4
....................             else 
....................                usb_request_stall(); 
0782:  MOVLB  0
0784:  RCALL  037A
....................             break; 
0786:  BRA    07C6
....................  
....................       case USB_STANDARD_REQUEST_SET_ADDRESS: //5 
....................             debug_usb(debug_putc,"SA"); 
....................             USB_stack_status.dev_req=SET_ADDRESS; //currently processing set_address request 
0788:  MOVLW  02
078A:  MOVWF  17
....................             USB_address_pending=usb_ep0_rx_buffer[2]; 
078C:  MOVFF  412,21
....................             #ifdef __USBN__   //NATIONAL part handles this differently than pic16c7x5 
....................             USB_stack_status.dev_req=NONE; //currently processing set_address request 
....................             usb_set_address(USB_address_pending); 
....................             USB_stack_status.curr_config=0;   // make sure current configuration is 0 
....................             #endif 
....................             usb_put_0len_0(); 
0790:  CLRF   x6C
0792:  RCALL  0374
....................             break; 
0794:  BRA    07C6
....................  
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: //6 
....................             debug_usb(debug_putc,"GD"); 
....................             usb_Get_Descriptor(); 
0796:  RCALL  044A
....................             break; 
0798:  BRA    07C6
....................  
....................       case USB_STANDARD_REQUEST_GET_CONFIGURATION: //8 
....................             debug_usb(debug_putc,"GC"); 
....................             usb_ep0_tx_buffer[0]=USB_stack_status.curr_config; 
079A:  MOVFF  18,450
....................             usb_request_send_response(1); 
079E:  MOVLW  01
07A0:  MOVWF  x6C
07A2:  RCALL  0374
....................             break; 
07A4:  BRA    07C6
....................  
....................       case USB_STANDARD_REQUEST_SET_CONFIGURATION: //9 
....................             if (usb_ep0_rx_buffer[2] <= USB_NUM_CONFIGURATIONS) { 
07A6:  MOVLB  4
07A8:  MOVF   x12,W
07AA:  SUBLW  01
07AC:  BNC   07C0
....................                USB_stack_status.curr_config=usb_ep0_rx_buffer[2]; 
07AE:  MOVFF  412,18
....................                usb_set_configured(usb_ep0_rx_buffer[2]); 
07B2:  MOVFF  412,69
07B6:  MOVLB  0
07B8:  BRA    056E
....................                debug_usb(debug_putc,"SC%U", USB_stack_status.curr_config);                
....................                usb_put_0len_0(); 
07BA:  CLRF   x6C
07BC:  RCALL  0374
07BE:  MOVLB  4
....................             } 
....................             break; 
07C0:  MOVLB  0
07C2:  BRA    07C6
....................  
....................       default: 
....................             usb_request_stall(); 
07C4:  RCALL  037A
....................             break; 
....................    } 
07C6:  GOTO   09E0 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Interface request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardInterface(void) { 
....................    unsigned int8 curr_config; 
....................  
....................    curr_config=USB_stack_status.curr_config; 
07CA:  MOVFF  18,69
....................  
....................    switch (usb_ep0_rx_buffer[1]) { 
07CE:  MOVLB  4
07D0:  MOVF   x11,W
07D2:  XORLW  00
07D4:  MOVLB  0
07D6:  BZ    07E6
07D8:  XORLW  0A
07DA:  BZ    07F6
07DC:  XORLW  01
07DE:  BZ    083A
07E0:  XORLW  0D
07E2:  BZ    085E
07E4:  BRA    0862
....................       case USB_STANDARD_REQUEST_GET_STATUS: 
....................             debug_usb(debug_putc,"GS"); 
....................             usb_ep0_tx_buffer[0]=0; 
07E6:  MOVLB  4
07E8:  CLRF   x50
....................             usb_ep0_tx_buffer[1]=0; 
07EA:  CLRF   x51
....................             usb_request_send_response(2); 
07EC:  MOVLW  02
07EE:  MOVLB  0
07F0:  MOVWF  x6C
07F2:  RCALL  0374
....................             break; 
07F4:  BRA    0864
....................  
....................       case USB_STANDARD_REQUEST_GET_INTERFACE: 
....................             if ( curr_config && (usb_ep0_rx_buffer[4] < USB_NUM_INTERFACES[curr_config-1]) ) {   //book says only supports configed state 
07F6:  MOVF   x69,F
07F8:  BZ    0836
07FA:  MOVLW  01
07FC:  SUBWF  x69,W
07FE:  CLRF   03
0800:  MOVFF  FF2,6A
0804:  BCF    FF2.7
0806:  RCALL  0198
0808:  BTFSC  x6A.7
080A:  BSF    FF2.7
080C:  MOVWF  01
080E:  MOVLB  4
0810:  SUBWF  x14,W
0812:  BTFSS  FD8.0
0814:  BRA    081A
0816:  MOVLB  0
0818:  BRA    0836
....................                debug_usb(debug_putc,"GI"); 
....................                usb_ep0_tx_buffer[0]=USB_Interface[usb_ep0_rx_buffer[4]];//our new outgoing byte 
081A:  CLRF   03
081C:  MOVF   x14,W
081E:  ADDLW  26
0820:  MOVWF  FE9
0822:  MOVLW  00
0824:  ADDWFC 03,W
0826:  MOVWF  FEA
0828:  MOVFF  FEF,450
....................                usb_request_send_response(1); //send byte back 
082C:  MOVLW  01
082E:  MOVLB  0
0830:  MOVWF  x6C
0832:  RCALL  0374
....................             } 
0834:  BRA    0838
....................             else 
....................                usb_request_stall(); 
0836:  RCALL  037A
....................             break; 
0838:  BRA    0864
....................  
....................       case USB_STANDARD_REQUEST_SET_INTERFACE: 
....................             if (curr_config) { //if configured state 
083A:  MOVF   x69,F
083C:  BZ    085A
....................                debug_usb(debug_putc,"SI"); 
....................                USB_Interface[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
083E:  CLRF   03
0840:  MOVLB  4
0842:  MOVF   x14,W
0844:  ADDLW  26
0846:  MOVWF  FE9
0848:  MOVLW  00
084A:  ADDWFC 03,W
084C:  MOVWF  FEA
084E:  MOVFF  412,FEF
....................                usb_put_0len_0(); 
0852:  MOVLB  0
0854:  CLRF   x6C
0856:  RCALL  0374
....................             } 
0858:  BRA    085C
....................             else 
....................                usb_request_stall(); 
085A:  RCALL  037A
....................             break; 
085C:  BRA    0864
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_STANDARD_REQUEST_GET_DESCRIPTOR: 
....................             debug_usb(debug_putc,"GDh"); 
....................             usb_Get_Descriptor(); 
085E:  RCALL  044A
....................             break; 
0860:  BRA    0864
.................... #endif 
....................  
.................... //      case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
.................... //      case USB_STANDARD_REQUEST_SET_FEATURE: 
.................... //                let default take care of these, goto wrongstate 
....................       default: 
....................             usb_request_stall(); 
0862:  RCALL  037A
....................             break; 
....................    } 
0864:  GOTO   09E0 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_StandardEndpoint() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Standard Endpoint request. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_isr_tkn_setup_StandardEndpoint(void) { 
....................    if (usb_endpoint_is_valid(usb_ep0_rx_buffer[4])) { 
*
0948:  MOVFF  414,73
094C:  RCALL  025A
094E:  MOVF   01,F
0950:  BZ    09A2
....................       switch(usb_ep0_rx_buffer[1]) { 
0952:  MOVLB  4
0954:  MOVF   x11,W
0956:  XORLW  01
0958:  MOVLB  0
095A:  BZ    0966
095C:  XORLW  02
095E:  BZ    0972
0960:  XORLW  03
0962:  BZ    097E
0964:  BRA    09A0
....................  
....................          case USB_STANDARD_REQUEST_CLEAR_FEATURE: 
....................                debug_usb(debug_putc,"CF"); 
....................                usb_unstall_ep(usb_ep0_rx_buffer[4]); 
0966:  MOVFF  414,69
096A:  BRA    0868
....................                usb_put_0len_0(); 
096C:  CLRF   x6C
096E:  RCALL  0374
....................                break; 
0970:  BRA    09A2
....................  
....................          case USB_STANDARD_REQUEST_SET_FEATURE: 
....................                      debug_usb(debug_putc,"SF"); 
....................                      usb_stall_ep(usb_ep0_rx_buffer[4]); 
0972:  MOVFF  414,69
0976:  BRA    08AC
....................                      usb_put_0len_0(); 
0978:  CLRF   x6C
097A:  RCALL  0374
....................                      break; 
097C:  BRA    09A2
....................  
....................          case USB_STANDARD_REQUEST_GET_STATUS: 
....................                debug_usb(debug_putc,"GS"); 
....................                usb_ep0_tx_buffer[0]=0; 
097E:  MOVLB  4
0980:  CLRF   x50
....................                usb_ep0_tx_buffer[1]=0; 
0982:  CLRF   x51
....................                if (usb_endpoint_stalled(usb_ep0_rx_buffer[4])) { 
0984:  MOVFF  414,69
0988:  MOVLB  0
098A:  BRA    08F2
098C:  MOVF   01,F
098E:  BZ    0998
....................                   usb_ep0_tx_buffer[0]=1; 
0990:  MOVLW  01
0992:  MOVLB  4
0994:  MOVWF  x50
0996:  MOVLB  0
....................                } 
....................                usb_request_send_response(2); 
0998:  MOVLW  02
099A:  MOVWF  x6C
099C:  RCALL  0374
....................                break; 
099E:  BRA    09A2
....................  
....................          default: 
....................             usb_request_stall(); 
09A0:  RCALL  037A
....................             break; 
....................       } 
....................    } 
09A2:  GOTO   09E0 (RETURN)
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_isr_tkn_setup_ClassInterface() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[1] == bRequest 
.................... /* 
.................... /* Summary: bmRequestType told us it was a Class request.  The only Class this drivers supports is HID. 
.................... /*          bRequest says which request.  Only certain requests are valid, 
.................... /*          if a non-valid request was made then return with an Wrong-Statue (IDLE) 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /* Only compiled if HID_DEVICE is TRUE 
.................... /***************************************************************/ 
.................... #IF USB_HID_DEVICE 
.................... void usb_isr_tkn_setup_ClassInterface(void) { 
....................    switch(usb_ep0_rx_buffer[1]) { 
09A6:  MOVLB  4
09A8:  MOVF   x11,W
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_GET_PROTOCOL:  //03 
....................             debug_usb(debug_putc,"GP"); 
....................             usb_ep0_tx_buffer[0]=hid_protocol[usb_ep0_rx_buffer[4]]; 
....................             usb_request_send_response(1); 
....................             break; 
....................     #ENDIF 
....................  
....................     #IF USB_HID_BOOT_PROTOCOL 
....................       case USB_HID_REQUEST_SET_PROTOCOL:  //0b 
....................             debug_usb(debug_putc,"SP"); 
....................             hid_protocol[usb_ep0_rx_buffer[4]]=usb_ep0_rx_buffer[2]; 
....................             usb_put_0len_0(); //send 0len packet69 
....................             break; 
....................     #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_SET_IDLE:   //0a 
....................          #error TODO: if you want to support SET_IDLE, add code here 
....................    #ENDIF 
....................  
....................    #IF USB_HID_IDLE 
....................       case USB_HID_REQUEST_GET_IDLE:   //02 
....................          #error TODO: if you want to support GET_IDLE, add code here 
....................    #ENDIF 
....................  
....................       default: 
....................             usb_request_stall(); 
09AA:  MOVLB  0
09AC:  RCALL  037A
....................             break; 
....................    } 
09AE:  GOTO   09E0 (RETURN)
.................... } 
.................... #ENDIF 
....................  
.................... /************************************************************** 
.................... /* usb_Get_Descriptor() 
.................... /* 
.................... /* Input: usb_ep0_rx_buffer[3] == wValue, which descriptor we want 
.................... /*        usb_ep0_rx_buffer[6,7] == Max length the host will accept 
.................... /* 
.................... /* Summary: Checks to see if we want a standard descriptor (Interface, Endpoint, Config, Device, String, etc.), 
.................... /*          or a class specific (HID) descriptor.  Since some pics (especially the PIC167x5) doesn't have 
.................... /*          pointers to constants we must simulate or own by setting up global registers that say 
.................... /*          which constant array to deal with, which position to start in this array, and the length. 
.................... /*          Once these globals are setup the first packet is sent.  If a descriptor takes more than one packet 
.................... /*          the PC will send an IN request to endpoint 0, and this will be handled by usb_isr_tok_in_dne() 
.................... /*          which will send the rest of the data. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
.................... void usb_Get_Descriptor() { 
....................    usb_getdesc_ptr=0; 
*
044A:  CLRF   23
044C:  CLRF   22
....................    USB_stack_status.getdesc_type=USB_GETDESC_CONFIG_TYPE; 
044E:  CLRF   1A
....................  
....................    switch(usb_ep0_rx_buffer[3]) { 
0450:  MOVLB  4
0452:  MOVF   x13,W
0454:  XORLW  01
0456:  MOVLB  0
0458:  BZ    046C
045A:  XORLW  03
045C:  BZ    0478
045E:  XORLW  01
0460:  BZ    0480
0462:  XORLW  22
0464:  BZ    04B8
0466:  XORLW  03
0468:  BZ    04FE
046A:  BRA    054A
....................       case USB_DESC_DEVICE_TYPE:    //1 
....................             usb_getdesc_len=USB_DESC_DEVICE_LEN; 
046C:  CLRF   25
046E:  MOVLW  12
0470:  MOVWF  24
....................             USB_stack_status.getdesc_type=USB_GETDESC_DEVICE_TYPE; 
0472:  MOVLW  03
0474:  MOVWF  1A
....................             break; 
0476:  BRA    054E
....................  
....................       //windows hosts will send a FF max len and expect you to send all configs without asking for them individually. 
....................       case USB_DESC_CONFIG_TYPE:   //2 
....................             usb_getdesc_len=USB_TOTAL_CONFIG_LEN; 
0478:  CLRF   25
047A:  MOVLW  29
047C:  MOVWF  24
....................             break; 
047E:  BRA    054E
....................  
....................       case USB_DESC_STRING_TYPE: //3 
....................             USB_stack_status.getdesc_type=USB_GETDESC_STRING_TYPE; 
0480:  MOVLW  02
0482:  MOVWF  1A
....................             usb_getdesc_ptr=USB_STRING_DESC_OFFSET[usb_ep0_rx_buffer[2]]; 
0484:  CLRF   03
0486:  MOVLB  4
0488:  MOVF   x12,W
048A:  ADDLW  1B
048C:  MOVWF  FE9
048E:  MOVLW  00
0490:  ADDWFC 03,W
0492:  MOVWF  FEA
0494:  CLRF   23
0496:  MOVFF  FEF,22
....................             usb_getdesc_len=USB_STRING_DESC[usb_getdesc_ptr]; 
049A:  MOVFF  23,03
049E:  MOVF   22,W
04A0:  MOVFF  FF2,6A
04A4:  BCF    FF2.7
04A6:  MOVLB  0
04A8:  RCALL  01DE
04AA:  BTFSC  x6A.7
04AC:  BSF    FF2.7
04AE:  CLRF   03
04B0:  MOVWF  24
04B2:  MOVFF  03,25
....................             break; 
04B6:  BRA    054E
....................  
....................       //case USB_DESC_DEVICE_QUALIFIER_TYPE:   //0x06 
....................       // this is needed so host can find out about differences about this 
....................       // devices ability to handle full speed verses fast speed. 
....................       // since we don't support fast speed then we ignore this. 
....................       //      break; 
....................  
.................... #IF USB_HID_DEVICE || USB_CDC_DEVICE 
....................       case USB_DESC_CLASS_TYPE:  //0x21 
....................             //TODO does this work for multiple interfaces or multiple languages? 
....................             //usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][usb_ep0_rx_buffer[4]][usb_ep0_rx_buffer[2]]; 
....................             usb_getdesc_ptr=USB_CLASS_DESCRIPTORS[0][0][usb_ep0_rx_buffer[2]]; 
04B8:  CLRF   03
04BA:  MOVLB  4
04BC:  MOVF   x12,W
04BE:  MOVFF  FF2,6A
04C2:  BCF    FF2.7
04C4:  MOVLB  0
04C6:  RCALL  01AA
04C8:  BTFSC  x6A.7
04CA:  BSF    FF2.7
04CC:  CLRF   03
04CE:  MOVWF  22
04D0:  MOVFF  03,23
....................             if (usb_getdesc_ptr!=0xFF) { 
04D4:  INCFSZ 22,W
04D6:  BRA    04DC
04D8:  MOVF   23,F
04DA:  BZ    04FA
....................                usb_getdesc_len=USB_CONFIG_DESC[usb_getdesc_ptr]; 
04DC:  MOVFF  23,03
04E0:  MOVF   22,W
04E2:  MOVFF  FF2,6A
04E6:  BCF    FF2.7
04E8:  RCALL  015E
04EA:  BTFSC  x6A.7
04EC:  BSF    FF2.7
04EE:  CLRF   03
04F0:  MOVWF  24
04F2:  MOVFF  03,25
....................                break; 
04F6:  BRA    054E
....................             } 
04F8:  BRA    04FE
....................             else { 
....................                usb_request_stall(); 
04FA:  RCALL  037A
....................                return; 
04FC:  BRA    056C
....................             } 
.................... #endif 
....................  
.................... #IF USB_HID_DEVICE 
....................       case USB_DESC_HIDREPORT_TYPE: //0x22 
....................             usb_getdesc_ptr=USB_CLASS_SPECIFIC_DESC_LOOKUP[0][usb_ep0_rx_buffer[4]]; 
04FE:  CLRF   03
0500:  MOVLB  4
0502:  MOVF   x14,W
0504:  MOVFF  FF2,6A
0508:  BCF    FF2.7
050A:  MOVLB  0
050C:  RCALL  013A
050E:  BTFSC  x6A.7
0510:  BSF    FF2.7
0512:  CLRF   03
0514:  MOVWF  22
0516:  MOVFF  03,23
....................             if (usb_getdesc_ptr !=0xFF) { 
051A:  INCFSZ 22,W
051C:  BRA    0522
051E:  MOVF   23,F
0520:  BZ    0546
....................                USB_stack_status.getdesc_type=USB_GETDESC_HIDREPORT_TYPE; 
0522:  MOVLW  01
0524:  MOVWF  1A
....................                usb_getdesc_len=USB_CLASS_SPECIFIC_DESC_LOOKUP_SIZE[0][usb_ep0_rx_buffer[4]]; 
0526:  CLRF   03
0528:  MOVLB  4
052A:  MOVF   x14,W
052C:  MOVFF  FF2,6A
0530:  BCF    FF2.7
0532:  MOVLB  0
0534:  RCALL  014C
0536:  BTFSC  x6A.7
0538:  BSF    FF2.7
053A:  CLRF   03
053C:  MOVWF  24
053E:  MOVFF  03,25
....................                break; 
0542:  BRA    054E
....................             } 
0544:  BRA    054A
....................             else { 
....................                usb_request_stall(); 
0546:  RCALL  037A
....................                return; 
0548:  BRA    056C
....................             } 
.................... #endif 
....................  
....................       default: 
....................             usb_request_stall(); 
054A:  RCALL  037A
....................             return; 
054C:  BRA    056C
....................    } 
....................    if (usb_ep0_rx_buffer[7]==0) { 
054E:  MOVLB  4
0550:  MOVF   x17,F
0552:  BNZ   0564
....................       if (usb_getdesc_len > usb_ep0_rx_buffer[6]) 
0554:  MOVF   25,F
0556:  BNZ   055E
0558:  MOVF   24,W
055A:  SUBWF  x16,W
055C:  BC    0564
....................          usb_getdesc_len = usb_ep0_rx_buffer[6]; 
055E:  CLRF   25
0560:  MOVFF  416,24
....................    } 
....................    USB_stack_status.dev_req=GET_DESCRIPTOR; 
0564:  MOVLW  01
0566:  MOVWF  17
....................    usb_copy_desc_seg_to_ep(); 
0568:  MOVLB  0
056A:  RCALL  037E
056C:  RETURN 0
.................... } 
....................  
.................... /************************************************************** 
.................... /* usb_finish_set_address() 
.................... /* 
.................... /* Input: USB_address_pending holds the address we were asked to set to. 
.................... /* 
.................... /* Summary: Sets the address. 
.................... /* 
.................... /* This code should only be run on the PIC USB peripheral, and not the 
.................... /* National peripheral. 
.................... /* 
.................... /* Part of usb_isr_tok_setup_dne() 
.................... /***************************************************************/ 
....................  void usb_finish_set_address() { 
....................    debug_usb(debug_putc," FSA "); 
....................    USB_stack_status.curr_config=0;   // make sure current configuration is 0 
*
0BDC:  CLRF   18
....................  
....................    #ifdef __PIC__ 
....................    USB_stack_status.dev_req=NONE;  // no request pending 
0BDE:  CLRF   17
....................    usb_set_address(USB_address_pending); 
0BE0:  MOVFF  21,6A
0BE4:  BRA    0BC6
....................    #endif 
0BE6:  GOTO   0C00 (RETURN)
.................... } 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... /// 
.................... /// The following function retrieve data from constant arrays.  This may 
.................... /// look un-optimized, but remember that you can't create a pointer to 
.................... /// a constant array. 
.................... /// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... void usb_copy_desc_seg_to_ep(void) { 
*
037E:  CLRF   x6A
....................    unsigned int i=0; 
....................    char c; 
....................     
....................    //debug_usb(debug_putc, "!%LX! ", &usb_ep0_tx_buffer[0]); 
....................  
....................    while ((usb_getdesc_len)&&(i<USB_MAX_EP0_PACKET_LENGTH)) 
0380:  MOVF   24,W
0382:  IORWF  25,W
0384:  BZ    0412
0386:  MOVF   x6A,W
0388:  SUBLW  3F
038A:  BNC   0412
....................    { 
....................       switch(USB_stack_status.getdesc_type) { 
038C:  MOVF   1A,W
038E:  ADDLW  FC
0390:  BC    03EE
0392:  ADDLW  04
0394:  GOTO   0428
....................          case USB_GETDESC_CONFIG_TYPE: 
....................             c=USB_CONFIG_DESC[usb_getdesc_ptr]; 
0398:  MOVFF  23,03
039C:  MOVF   22,W
039E:  MOVFF  FF2,6C
03A2:  BCF    FF2.7
03A4:  RCALL  015E
03A6:  BTFSC  x6C.7
03A8:  BSF    FF2.7
03AA:  MOVWF  x6B
....................             break; 
03AC:  BRA    03EE
....................  
....................         #IF USB_HID_DEVICE 
....................          case USB_GETDESC_HIDREPORT_TYPE: 
....................             c=USB_CLASS_SPECIFIC_DESC[usb_getdesc_ptr]; 
03AE:  MOVFF  23,03
03B2:  MOVF   22,W
03B4:  MOVFF  FF2,6C
03B8:  BCF    FF2.7
03BA:  RCALL  010A
03BC:  BTFSC  x6C.7
03BE:  BSF    FF2.7
03C0:  MOVWF  x6B
....................             break; 
03C2:  BRA    03EE
....................         #endif 
....................  
....................          case USB_GETDESC_STRING_TYPE: 
....................             c=USB_STRING_DESC[usb_getdesc_ptr]; 
03C4:  MOVFF  23,03
03C8:  MOVF   22,W
03CA:  MOVFF  FF2,6C
03CE:  BCF    FF2.7
03D0:  RCALL  01DE
03D2:  BTFSC  x6C.7
03D4:  BSF    FF2.7
03D6:  MOVWF  x6B
....................             break; 
03D8:  BRA    03EE
....................  
....................          case USB_GETDESC_DEVICE_TYPE: 
....................             c=USB_DEVICE_DESC[usb_getdesc_ptr]; 
03DA:  MOVFF  23,03
03DE:  MOVF   22,W
03E0:  MOVFF  FF2,6C
03E4:  BCF    FF2.7
03E6:  RCALL  01BC
03E8:  BTFSC  x6C.7
03EA:  BSF    FF2.7
03EC:  MOVWF  x6B
....................             //debug_usb(debug_putc, "-%X- ", c); 
....................             break; 
....................       } 
....................       usb_getdesc_ptr++; 
03EE:  INCF   22,F
03F0:  BTFSC  FD8.2
03F2:  INCF   23,F
....................       usb_getdesc_len--; 
03F4:  MOVF   24,W
03F6:  BTFSC  FD8.2
03F8:  DECF   25,F
03FA:  DECF   24,F
....................       usb_ep0_tx_buffer[i++]=c; 
03FC:  MOVF   x6A,W
03FE:  INCF   x6A,F
0400:  CLRF   03
0402:  ADDLW  50
0404:  MOVWF  FE9
0406:  MOVLW  04
0408:  ADDWFC 03,W
040A:  MOVWF  FEA
040C:  MOVFF  6B,FEF
0410:  BRA    0380
....................    } 
....................  
....................    if ((!usb_getdesc_len)&&(i!=USB_MAX_EP0_PACKET_LENGTH)) { 
0412:  MOVF   24,W
0414:  IORWF  25,W
0416:  BNZ   0420
0418:  MOVF   x6A,W
041A:  SUBLW  40
041C:  BZ    0420
....................          USB_stack_status.dev_req = NONE; 
041E:  CLRF   17
....................    } 
....................  
....................    usb_request_send_response(i); 
0420:  MOVFF  6A,6C
0424:  RCALL  0374
0426:  RETURN 0
.................... } 
....................  
.................... #ENDIF 
....................  
.................... #include <usbn960x.h> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                      usbn960x.h                                 //// 
.................... ////                                                                 //// 
.................... //// National USBN960x Hardware layer for CCS's PIC USB driver.      //// 
.................... ////                                                                 //// 
.................... //// This example USB peripheral layer was written and tested with   //// 
.................... //// CCS's USB Full Speed demo board.  When using your own design,   //// 
.................... //// either wire your USB960x the same as our demo board or change   //// 
.................... //// the port and pin definitions below.                             //// 
.................... ////                                                                 //// 
.................... //// Hardware only supports 3 endpoints (not counting endpoint 0).   //// 
.................... ////                                                                 //// 
.................... //// The following definitions must be made in order to communicate  //// 
.................... //// with the USBN960x device (default config is made in this        //// 
.................... //// file if not specified by the user):                             //// 
.................... ////     usbn_bus_out(x)                                             //// 
.................... ////     usbn_bus_in()                                               //// 
.................... ////     usbn_bus_float()                                            //// 
.................... ////     usbn_bus_control()                                          //// 
.................... ////     USBN_INT       PIN_B0                                       //// 
.................... ////     USBN_RS        PIN_C1                                       //// 
.................... ////     USBN_CS        PIN_C2                                       //// 
.................... ////     USBN_RD        PIN_C3                                       //// 
.................... ////     USBN_WR        PIN_C4                                       //// 
.................... ////     USBN_A0        PIN_C5                                       //// 
.................... ////                                                                 //// 
.................... //// This file is part of CCS's PIC USB driver code.  See USB.H      //// 
.................... //// for more documentation and a list of examples.                  //// 
.................... ////                                                                 //// 
.................... ////   *************************  NOTE  **************************   //// 
.................... //// This driver uses INT_EXT.  It requires INT_EXT to interrupt the //// 
.................... //// PIC when an event has happened on the USBN960x.  Because of     //// 
.................... //// this code enables interrupts.  A user modification can be made  //// 
.................... //// to poll the USBN960x device instead of relying on an interrupt. //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... //// Version History:                                                //// 
.................... ////                                                                 //// 
.................... //// March 5th, 2009:                                                //// 
.................... ////   Cleanup for Wizard.                                           //// 
.................... ////   PIC24 Initial release.                                        //// 
.................... ////                                                                 //// 
.................... //// 11-03-05:                                                       //// 
.................... ////   The way EP0 is flushed and enabled in the TX and RX           //// 
.................... ////      interrupts and put and get packet routines completely      //// 
.................... ////      overhauled.                                                //// 
.................... ////   TX and RX interrupt handler cleaned up.                       //// 
.................... ////                                                                 //// 
.................... //// 10-27-05:                                                       //// 
.................... ////   usb_get_packet_buffer() added.                                //// 
.................... ////   usb_flush_out() added.                                        //// 
.................... ////                                                                 //// 
.................... //// 06-30-05:                                                       //// 
.................... ////    usb_tbe() added                                              //// 
.................... ////    The way endpoint 0 DTS is set has been changed.              //// 
.................... ////    usb_kbhit() moved back to usb.c                              //// 
.................... ////    Fixed a bug where EP0 wasn't being stalled if an invalid     //// 
.................... ////        setup request was made by the host.                      //// 
.................... ////    Added usb_get_packet_status()                                //// 
.................... ////                                                                 //// 
.................... //// June 20th, 2005:                                                //// 
.................... ////    18Fxx5x initial release                                      //// 
.................... ////    Functions now use newer USB_DTS_BIT enum.                    //// 
.................... ////    usb_ep0_rx_buffer[] and usb_ep0_tx_buffer[] moved from usb.h //// 
.................... ////    usb_kbhit() added.                                           //// 
.................... ////    usb_attached() added.                                        //// 
.................... ////    usb_task() added.                                            //// 
.................... ////    usb_flush_packet_0() added.                                  //// 
.................... ////    usb_init_cs() added.                                         //// 
.................... ////    usb_attach() added.                                          //// 
.................... ////    usb_detach() added.                                          //// 
.................... ////                                                                 //// 
.................... //// June 24th, 2004:                                                //// 
.................... ////    Optimization and cleanup.                                    //// 
.................... ////    Some definitions may have changed.                           //// 
.................... ////    usb_find_epc(), usb_stall_ep(), usb_unstall_ep(), and        //// 
.................... ////       usb_endpoint_stalled() don't have direction as a          //// 
.................... ////       parameter.  Will get direction from bit7 of the endpoint. //// 
.................... ////                                                                 //// 
.................... //// October 27th, 2003: RX/TX - IN/OUT Backwards                    //// 
.................... ////                             in usb_set_configured()             //// 
.................... ////                                                                 //// 
.................... //// June 18th, 2003: Fixed a problem where PIC would miss interrupt //// 
.................... ////                                                                 //// 
.................... //// May 6th, 2003: Fixed a potential read/write to registers        //// 
.................... ////                                                                 //// 
.................... //// August 2nd, 2002: Initial Public Release                        //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2005 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #IFNDEF __USBN960X_H__ 
.................... #DEFINE __USBN960X_H__ 
....................  
.................... #DEFINE __USB_HARDWARE__ 
....................  
.................... #ifndef USB_USE_FULL_SPEED 
....................    #define USB_USE_FULL_SPEED TRUE 
.................... #endif 
....................  
.................... #define USB_MAX_EP0_PACKET_LENGTH   8 
....................  
.................... #define __USBN__ 1   //let other parts of the code know that we are running a National USB Part 
....................  
.................... //CCS USB demo board is connected to the USBN960x in this manner: 
.................... #ifndef usbn_out 
....................    #define  usbn_bus_out(x)      output_d(x) 
....................    #define  usbn_bus_in          input_d 
....................    #define  usbn_bus_float()     set_tris_d(0xFF) 
....................    #define  usbn_bus_control()   set_tris_d(0) 
.................... #endif 
....................  
.................... //CCS USB demo board is connected to the USBN960x in this manner: 
.................... #ifndef  USBN_CS 
....................    #define  USBN_INT       PIN_B0   //leave at B0 if you want to use external interrupt 
....................    #define  USBN_RS        PIN_C1   //reset 
....................    #define  USBN_CS        PIN_C2 
....................    #define  USBN_RD        PIN_C3 
....................    #define  USBN_WR        PIN_C4 
....................    #define  USBN_A0        PIN_C5 
.................... #endif 
....................  
.................... #include <usb_hw_layer.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                         usb_hw_layer.h                            //// 
.................... ////                                                                   //// 
.................... //// HW Layer for the USB Stack.                                       //// 
.................... ////                                                                   //// 
.................... //// HW drivers for the USB stack must support this API.               //// 
.................... ////                                                                   //// 
.................... //// The HW driver must also have a token handler that will call       //// 
.................... //// usb_token_reset() when the device is init/reset, will call        //// 
.................... //// usb_isr_tok_setup_dne() when it receives a setup packet,          //// 
.................... //// will call usb_isr_tok_out_dne() when a new packet is received,    //// 
.................... //// and will call usb_isr_tok_in_dne() when a new packet is sent.     //// 
.................... //// See usb.h for documentation of these functions.                   //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                   //// 
.................... //// Version History:                                                  //// 
.................... ////                                                                   //// 
.................... //// March 5th, 2009:                                                  //// 
.................... ////   Cleanup for Wizard.                                             //// 
.................... ////   PIC24 Initial release.                                          //// 
.................... ////                                                                   //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2009 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS    //// 
.................... //// C compiler.  This source code may only be distributed to other    //// 
.................... //// licensed users of the CCS C compiler.  No other use,              //// 
.................... //// reproduction or distribution is permitted without written         //// 
.................... //// permission.  Derivative programs created using this software      //// 
.................... //// in object code form are not restricted in any way.                //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __USB_HW_LAYER_H__ 
.................... #define __USB_HW_LAYER_H__ 
....................  
.................... enum USB_DTS_BIT {USB_DTS_DATA1=1, USB_DTS_TOGGLE=2, USB_DTS_DATA0=0, 
....................                    USB_DTS_STALL=3, USB_DTS_USERX=4}; 
....................  
....................  
.................... // USER LEVEL FUNCTIONS: 
....................  
.................... /***************************************************************************** 
.................... /* usb_init() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_init_cs() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_init_cs(void); 
....................  
.................... /***************************************************************************** 
.................... /* usb_task() 
.................... /* 
.................... /* Summary: See API section of USB.H for documentation. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_task(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_attach() 
.................... /* 
.................... /* Summary: Attach the D+/D- lines to the USB bus.  Enable the USB peripheral. 
.................... /* 
.................... /* You should wait until UCON_SE0 is clear before enabling reset/idle interrupt. 
.................... /*  
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_attach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_detach() 
.................... /* 
.................... /* Summary: Remove the D+/D- lines from the USB bus.  Basically, disable USB. 
.................... /* 
.................... /* Shouldn't be called by user, let usb_task() handle this. 
.................... /* 
.................... /* If the user does call this function while USB is connected, the USB  
.................... /* peripheral will be disabled only momentarily because usb_task() will 
.................... /* reconnect.  But this is a great way to cause the PC/HOST to cause a USB 
.................... /* reset of the device. 
.................... /* 
.................... /* NOTE: If you are writing a new HW driver, this routine should call  
.................... /*       usb_token_reset() to reset the CH9 stack. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_detach(void); 
....................  
.................... /****************************************************************************** 
.................... /* usb_put_packet() 
.................... /* 
.................... /* Input: endpoint - endpoint to send packet to (0..15). 
.................... /*        ptr - points to data to send. 
.................... /*        len - amount of data to send. 
.................... /*        toggle - whether to send data with a DATA0 pid, a DATA1 pid,  
.................... /*                 or toggle from the last DATAx pid. 
.................... /* 
.................... /* Output: TRUE if data was sent correctly, FALSE if it was not.  The only  
.................... /*         reason it will return FALSE is if because the TX buffer is still full  
.................... /*         from the last time it tried to send a packet. 
.................... /* 
.................... /* Summary: Sends one packet out the EP to the host.  Notice that there is a  
.................... /*          difference between a packet and a message.  If you wanted to send a  
.................... /*          512 byte message on an endpoint that only supported 64 byte packets, 
.................... /*          this would be accomplished this by sending 8 64-byte packets,  
.................... /*          followed by a 0 length packet.  If the last (or only packet) being  
.................... /*          sent is less than the max packet size defined in your descriptor  
.................... /*          then you do not need to send a 0 length packet to identify 
.................... /*          an end of message. 
.................... /* 
.................... /*          usb_puts() (provided in usb.c) will send a multi-packet message  
.................... /*          correctly and know if a 0 lenght packet needs to be sent. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_put_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 len, USB_DTS_BIT tgl); 
....................  
.................... /******************************************************************************* 
.................... /* usb_get_packet(endpoint, *ptr, max) 
.................... /* 
.................... /* Input: endpoint - endpoint to get data from 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: the amount of data taken from the buffer and saved to ptr. 
.................... /* 
.................... /*         NOTE - IF THERE IS NO PACKET TO GET YOU WILL GET INVALID RESULTS! 
.................... /*                VERIFY WITH USB_KBHIT() BEFORE YOU CALL USB_GET_PACKET()! 
.................... /* 
.................... /* Summary: Gets a packet of data from the USB endpoint buffer. 
.................... /*          Until this is called, if there is data in the receive buffer the 
.................... /*          PC/HOST will be prevented from sending more data.  Upon completion 
.................... /*          of this call, the endpoint will be freed and the PC/HOST will be 
.................... /*          allowed to send a new packet.  Only receives one packet, if you need  
.................... /*          to receive multiple packets or handle 0-length terminator packets, 
.................... /*          then use usb_gets(). 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /********************************************************************************/ 
.................... unsigned int16 usb_get_packet(unsigned int8 endpoint, unsigned int8 * ptr, unsigned int16 max); 
....................  
.................... /**************************************************************************** 
.................... /* usb_kbhit(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check (0..15) 
.................... /* 
.................... /* Output: TRUE if there is new data in RX buffer, FALSE if there is not. 
.................... /* 
.................... /* Summary: Similar to kbhit(), sees if there is new data in the RX USB buffers. 
.................... /*          See API section of USB.H for more information. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_RX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_kbhit(unsigned int8 en); 
....................  
.................... /****************************************************************************** 
.................... /* usb_tbe(endpoint) 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*        ptr - where to save data to local PIC RAM 
.................... /*        max - max amount of data to receive from buffer 
.................... /* 
.................... /* Output: returns TRUE if this endpoint's IN buffer (PIC-PC) is empty and ready 
.................... /*         returns FALSE if this endpoint's IN buffer is still processing the last 
.................... /*         transmit or if this endpoint is invalid. 
.................... /* 
.................... /* The result will be invalid if the specified input has not been configured for 
.................... /* use by the API with USB_EPx_TX_SIZE 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_tbe(unsigned int8 en); 
....................  
.................... //////////////// END USER LEVEL FUNCTIONS ///////////////////////////////////// 
....................  
....................  
.................... /// 
.................... /// BEGIN STACK LEVEL FUNCTIONS: These functions are meant to be called by 
.................... ///            the USB stack, and are not meant to be called by the  
.................... ///            user/application. 
.................... /// 
....................  
.................... /***************************************************************************** 
.................... /* usb_stall_ep() 
.................... /* 
.................... /* Input: endpoint - endpoint to stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Stalls specified endpoint.  If endpoint is stalled it will 
.................... /*          send STALL packet if the host tries to access this endpoint's  
.................... /*          buffer. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_stall_ep(unsigned int8 endpoint); 
....................  
....................  
.................... /***************************************************************************** 
.................... /* usb_unstall_ep(endpoint, direction) 
.................... /* 
.................... /* Input: endpoint - endpoint to un-stall. 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Summary: Un-stalls endpoint. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_unstall_ep(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_endpoint_stalled() 
.................... /* 
.................... /* Input: endpoint - endpoint to check 
.................... /*                   top most bit indicates direction (set is IN, clear is OUT) 
.................... /* 
.................... /* Output: returns a TRUE if endpoint is stalled, FALSE if it is not. 
.................... /* 
.................... /* Summary: Looks to see if an endpoint is stalled, or not.  Does not look to 
.................... /*          see if endpoint has been issued a STALL, just whether or not it is 
.................... /*          configured to STALL on the next packet.  See Set_Feature and  
.................... /*          Clear_Feature Chapter 9 requests. 
.................... /* 
.................... /* NOTE: WE ASSUME ENDPOINT IS VALID.  USB.C SHOULD CHECK IF VALID BEFORE 
.................... /*       CALLING THIS ROUTINE. 
.................... /* 
.................... /*****************************************************************************/ 
.................... int1 usb_endpoint_stalled(unsigned int8 endpoint); 
....................  
.................... /***************************************************************************** 
.................... /* usb_set_address(address) 
.................... /* 
.................... /* Input: address - address the host specified that we use 
.................... /* 
.................... /* Summary: Configures the USB Peripheral for the specified device address.   
.................... /*          The host will now talk to use with the following address. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_address(unsigned int8 address); 
....................  
.................... /****************************************************************************** 
.................... /* usb_set_configured() 
.................... /* 
.................... /* Input: config - Configuration to use.  0 to uncofigure device. 
.................... /* 
.................... /* Summary: Configures or unconfigures device.  If configuring device it will 
.................... /*          enable all the endpoints the user specified for this configuration. 
.................... /*          If un-configuring device it will disable all endpoints. 
.................... /* 
.................... /*          NOTE: CCS only provides code to handle 1 configuration. 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_set_configured(unsigned int8 config); 
....................  
.................... /****************************************************************************** 
.................... /* usb_disable_endpoints() 
.................... /* 
.................... /* Summary: Disables endpoints (all endpoints but 0) 
.................... /* 
.................... /*****************************************************************************/ 
.................... void usb_disable_endpoints(void); 
....................  
....................  
.................... /******************************************************************************* 
.................... /* usb_disable_endpoint() 
.................... /* 
.................... /* Input: Endpoint to disable (0..15) 
.................... /* 
.................... /* Summary: Disables specified endpoint 
.................... /* 
.................... /********************************************************************************/ 
.................... void usb_disable_endpoint(unsigned int8 en); 
....................  
.................... /************************************************************** 
.................... /* usb_request_send_response(len) 
.................... /* usb_request_get_data() 
.................... /* usb_request_stall() 
.................... /* 
.................... /* Input: len - size of packet to send 
.................... /* 
.................... /* Summary: One of these 3 functions will be called by the USB stack after 
.................... /*          handling a SETUP packet. 
.................... /*           
.................... /*          After we process a SETUP request, we have 1 of three responses: 
.................... /*            1.) send a response IN packet 
.................... /*            2.) wait for followup OUT packet(s) with data 
.................... /*            3.) stall because we don't support that SETUP request 
.................... /* 
.................... /*          If we are sending data, the array usb_ep0_tx_buffer[] will hold 
.................... /*          the response and the USB Request handler code will call 
.................... /*          usb_request_send_response() to let us know how big the packet is. 
.................... /* 
.................... /*          If we are waiting for more data, usb_request_get_data() will 
.................... /*          be called by the USB request handler code to configure the EP0 OUT 
.................... /*          endpoint to be ready for more data 
.................... /* 
.................... /*          If we don't support a request, usb_request_stall() will be called 
.................... /*          by the USB request handler code to stall the endpoint 0. 
.................... /* 
.................... /*          The operation of these functions depends on how SETUP packets 
.................... /*          are handled in the hardware layer. 
.................... /* 
.................... /***************************************************************/ 
.................... void usb_request_send_response(unsigned int8 len); 
.................... void usb_request_get_data(void); 
.................... void usb_request_stall(void); 
....................  
....................  
.................... #endif 
....................  
....................  
.................... //////////////////////// EXTRA USER FUNCTIONS ///////////////////////////////// 
....................  
....................  // NO EXTRA USER FUNCTIONS // 
....................  
.................... #ENDIF 
....................  
.................... // include lb RFID 
.................... #include <em4095.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                             em4095.c                            //// 
.................... //// This file contains drivers for a EM4095 RFID basestation.       //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                                                                 //// 
.................... ////                          Pin Layout                             //// 
.................... ////   ------------------------------------------------------------  //// 
.................... ////   |                                                          |  //// 
.................... ////   | 1: VSS       GND         | 16: DC2                       |  //// 
.................... ////   |                          |                               |  //// 
.................... ////   | 2: RDY/CLK   RF_RDY_CLK  | 15: FCAP                      |  //// 
.................... ////   |                          |                               |  //// 
.................... ////   | 3: ANT1                  | 14: SHD         RF_SHD        |  //// 
.................... ////   |                          |                               |  //// 
.................... ////   | 4: DVDD                  | 13: DEMOD_OUT   RF_DEMOD_OUT  |  //// 
.................... ////   |                          |                               |  //// 
.................... ////   | 5: DVDS                  | 12: MOD         RF_MOD        |  //// 
.................... ////   |                          |                               |  //// 
.................... ////   | 6: ANT2                  | 11: AGND                      |  //// 
.................... ////   |                          |                               |  //// 
.................... ////   | 7: VDD       +5V         | 10: CDEC_IN                   |  //// 
.................... ////   |                          |                               |  //// 
.................... ////   | 8: DMOD_IN               |  9: CDEC_OUT                  |  //// 
.................... ////   ------------------------------------------------------------  //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef EM4095 
.................... #define EM4095 
....................  
.................... #ifndef RF_SHD 
.................... #define RF_RDY_CLK   PIN_C0         // External interrupt used to read clock 
.................... #define RF_SHD       PIN_B1         // High disables the antenna signal 
.................... #define RF_MOD       PIN_B2         // High does 100% modulation 
.................... #define RF_DEMOD_OUT PIN_C2         // Data read in interrupt service routine 
.................... #endif 
....................  
....................  
.................... // Provide a buffer for storing recieved data and data to be sent 
.................... #define RFBUFFER_SIZE 20 
.................... int8 RFbuffer[RFBUFFER_SIZE]; 
.................... int8 RFbuffer_index = 0; 
.................... int8 RFbuffer_bitIndex = 0; 
.................... #define END_OF_RFBUFFER (RFbuffer_index == sizeof(RFbuffer)) 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Read modes available for reading data from a transponder 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... int8 RF_readMode; 
.................... #define RF_MANCHESTER_DATA    0     // Reads Manchester encoded data 
.................... #define RF_MEASURE_WIDTHS     1     // Measure a series of widths 
.................... #define RF_FIND_WIDTH         2     // Find a specific width 
.................... #define RF_FIND_PATTERN       3     // Find a pattern of widths 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... ///////////////////////////////////////////////////////////////////////// 
.................... //// Global Variables 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... int1  bitValue              = 1; 
.................... int1  storeData             = TRUE; 
.................... int1  RE_FE_TOGGLE          = 1; 
.................... int1  RF_widthFound         = FALSE; 
.................... int1  RF_patternFound       = FALSE; 
.................... int8  RF_widthToFind        = 0; 
.................... int8* RF_findWidths         = 0; 
.................... int8  RF_uncertainty        = 0; 
.................... int8  timer0_overflows      = 0; 
.................... int8  dataTransferred       = 0; 
.................... int16 old_clock             = 0; 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... // Purpose:       Initializes the 4095 into sleep mode 
.................... //                Sets up the timers and interrupts 
.................... void rf_init() 
.................... { 
....................    output_low(RF_SHD); 
*
10AC:  BCF    F93.1
10AE:  BCF    F8A.1
....................    output_low(RF_MOD); 
10B0:  BCF    F93.2
10B2:  BCF    F8A.2
....................  
....................    setup_timer_1(T1_EXTERNAL_SYNC | T1_DIV_BY_1); 
10B4:  MOVLW  83
10B6:  MOVWF  FCD
....................    setup_ccp1(CCP_CAPTURE_RE); 
10B8:  BSF    F94.2
10BA:  CLRF   FBD
10BC:  MOVLW  05
10BE:  MOVWF  FBD
....................    setup_ccp2(CCP_COMPARE_INT); 
10C0:  MOVLW  0A
10C2:  MOVWF  FBA
....................  
....................    setup_timer_0(RTCC_INTERNAL | RTCC_DIV_256 | RTCC_8_BIT); 
10C4:  MOVLW  C7
10C6:  MOVWF  FD5
....................    enable_interrupts(INT_RTCC); 
10C8:  BSF    FF2.5
....................    enable_interrupts(GLOBAL); 
10CA:  MOVLW  C0
10CC:  IORWF  FF2,F
10CE:  GOTO   169C (RETURN)
.................... } 
....................  
.................... // Purpose:       Powers down the RF antenna 
.................... #define rf_powerDown()  output_high(RF_SHD); 
....................  
.................... // Purpose:       Powers up the RF antenna 
.................... #define rf_powerUp()    output_low(RF_SHD); 
....................  
....................  
.................... // Purpose:       Select which edge to begin reading data 
.................... void RF_readEdge(int1 edge) 
.................... { 
....................    if(edge) 
*
117C:  MOVF   5A,F
117E:  BZ    118C
....................    { 
....................       setup_ccp1(CCP_CAPTURE_RE); 
1180:  BSF    F94.2
1182:  CLRF   FBD
1184:  MOVLW  05
1186:  MOVWF  FBD
....................       RE_FE_TOGGLE = 1; 
1188:  BSF    3E.2
....................    } 
118A:  BRA    1196
....................    else 
....................    { 
....................       setup_ccp1(CCP_CAPTURE_FE); 
118C:  BSF    F94.2
118E:  CLRF   FBD
1190:  MOVLW  04
1192:  MOVWF  FBD
....................       RE_FE_TOGGLE = 0; 
1194:  BCF    3E.2
....................    } 
1196:  GOTO   11A0 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Interrupt service routine to handle compare 1 interrupts. 
.................... //                Reads incoming data from a transponder and stores it in 
.................... //                the global buffer. 
.................... #INT_CCP1 
.................... void isr_ccp1() 
.................... { 
....................    int8  width; 
....................  
....................    // Toggle between capturing rising and falling edges to meausure width 
....................    if(RE_FE_TOGGLE) 
*
0D3E:  BTFSS  3E.2
0D40:  BRA    0D4E
....................    { 
....................       setup_ccp1(CCP_CAPTURE_FE); 
0D42:  BSF    F94.2
0D44:  CLRF   FBD
0D46:  MOVLW  04
0D48:  MOVWF  FBD
....................       RE_FE_TOGGLE = 0; 
0D4A:  BCF    3E.2
....................    } 
0D4C:  BRA    0D58
....................    else 
....................    { 
....................       setup_ccp1(CCP_CAPTURE_RE); 
0D4E:  BSF    F94.2
0D50:  CLRF   FBD
0D52:  MOVLW  05
0D54:  MOVWF  FBD
....................       RE_FE_TOGGLE = 1; 
0D56:  BSF    3E.2
....................    } 
....................  
....................    // Calculate the width 
....................    width = CCP_1 - old_clock; 
0D58:  MOVF   45,W
0D5A:  SUBWF  FBE,W
0D5C:  MOVWF  x66
....................    old_clock = CCP_1; 
0D5E:  MOVFF  FBF,46
0D62:  MOVFF  FBE,45
....................  
....................    switch(RF_readMode) 
0D66:  MOVF   3D,W
0D68:  ADDLW  FC
0D6A:  BTFSC  FD8.0
0D6C:  BRA    0E9E
0D6E:  ADDLW  04
0D70:  GOTO   0EA4
....................    { 
....................       // Use to receive manchester formatted data from a transponder 
....................       case RF_MANCHESTER_DATA: 
....................       { 
....................          if(width > 54)           // Check for a phase change 
0D74:  MOVF   x66,W
0D76:  SUBLW  36
0D78:  BC    0D7E
....................          { 
....................             bitValue = ~bitValue; // Invert the save bit value 
0D7A:  BTG    3E.0
....................             storeData = TRUE;     // Force a bit store 
0D7C:  BSF    3E.1
....................          } 
....................  
....................          if(storeData) 
0D7E:  BTFSS  3E.1
0D80:  BRA    0DB0
....................          { 
....................             shift_right(RFbuffer+RFbuffer_index, 1, bitValue); 
0D82:  MOVLW  27
0D84:  ADDWF  3B,W
0D86:  MOVWF  x6A
0D88:  CLRF   x6B
0D8A:  BTFSC  FD8.0
0D8C:  INCF   x6B,F
0D8E:  BTFSC  3E.0
0D90:  BRA    0D96
0D92:  BCF    FD8.0
0D94:  BRA    0D98
0D96:  BSF    FD8.0
0D98:  MOVFF  6B,FEA
0D9C:  MOVFF  6A,FE9
0DA0:  RRCF   FED,F
....................             ++dataTransferred; 
0DA2:  INCF   44,F
....................  
....................             if(++RFbuffer_bitIndex == 8) 
0DA4:  INCF   3C,F
0DA6:  MOVF   3C,W
0DA8:  SUBLW  08
0DAA:  BNZ   0DB0
....................             { 
....................                RFbuffer_bitIndex = 0; 
0DAC:  CLRF   3C
....................                ++RFbuffer_index; 
0DAE:  INCF   3B,F
....................             } 
....................          } 
....................  
....................          storeData = ~storeData; 
0DB0:  BTG    3E.1
....................          break; 
0DB2:  BRA    0E9E
....................       } 
....................  
....................       // Use to read high and low widths 
....................       case RF_MEASURE_WIDTHS: 
....................       { 
....................          RFbuffer[RFbuffer_index++] = width; 
0DB4:  MOVF   3B,W
0DB6:  INCF   3B,F
0DB8:  CLRF   03
0DBA:  ADDLW  27
0DBC:  MOVWF  FE9
0DBE:  MOVLW  00
0DC0:  ADDWFC 03,W
0DC2:  MOVWF  FEA
0DC4:  MOVFF  66,FEF
....................          ++dataTransferred; 
0DC8:  INCF   44,F
....................  
....................          break; 
0DCA:  BRA    0E9E
....................       } 
....................  
....................       // Use to search for a certain pulse width 
....................       case RF_FIND_WIDTH: 
....................       { 
....................          if(width > (RF_widthToFind - RF_uncertainty) 
....................          && width < (RF_widthToFind + RF_uncertainty)) 
0DCC:  MOVF   42,W
0DCE:  SUBWF  3F,W
0DD0:  SUBWF  x66,W
0DD2:  BZ    0DE0
0DD4:  BNC   0DE0
0DD6:  MOVF   42,W
0DD8:  ADDWF  3F,W
0DDA:  SUBWF  x66,W
0DDC:  BC    0DE0
....................          { 
....................             RF_widthFound = TRUE; 
0DDE:  BSF    3E.3
....................          } 
....................          break; 
0DE0:  BRA    0E9E
....................       } 
....................  
....................       case RF_FIND_PATTERN: 
....................       { 
....................          if(width > RF_findWidths[RFbuffer_index] - RF_uncertainty 
....................          && width < RF_findWidths[RFbuffer_index] + RF_uncertainty) 
0DE2:  CLRF   03
0DE4:  MOVF   3B,W
0DE6:  ADDWF  40,W
0DE8:  MOVWF  FE9
0DEA:  MOVF   41,W
0DEC:  ADDWFC 03,W
0DEE:  MOVWF  FEA
0DF0:  MOVF   42,W
0DF2:  SUBWF  FEF,W
0DF4:  SUBWF  x66,W
0DF6:  BZ    0E1C
0DF8:  BNC   0E1C
0DFA:  CLRF   03
0DFC:  MOVF   3B,W
0DFE:  ADDWF  40,W
0E00:  MOVWF  FE9
0E02:  MOVF   41,W
0E04:  ADDWFC 03,W
0E06:  MOVWF  FEA
0E08:  MOVF   42,W
0E0A:  ADDWF  FEF,W
0E0C:  SUBWF  x66,W
0E0E:  BC    0E1C
....................          { 
....................             if(++RFbuffer_index == dataTransferred) 
0E10:  INCF   3B,F
0E12:  MOVF   44,W
0E14:  SUBWF  3B,W
0E16:  BNZ   0E1A
....................             { 
....................                RF_patternFound = TRUE; 
0E18:  BSF    3E.4
....................             } 
....................          } 
0E1A:  BRA    0E9E
....................          else 
....................          { 
....................             if(RFbuffer_index > 0) 
0E1C:  MOVF   3B,F
0E1E:  BZ    0E9E
....................             { 
....................                int8 pos, i, j; 
....................                pos = RFbuffer_index-1;   // Save the initial position 
0E20:  MOVLW  01
0E22:  SUBWF  3B,W
0E24:  MOVWF  x67
....................  
....................                // Try to match partial pattern 
....................                while(--RFbuffer_index != 0) 
0E26:  DECF   3B,F
0E28:  BZ    0E9E
....................                { 
....................                   if(width > RF_findWidths[RFbuffer_index] - RF_uncertainty 
....................                   && width < RF_findWidths[RFbuffer_index] + RF_uncertainty) 
0E2A:  CLRF   03
0E2C:  MOVF   3B,W
0E2E:  ADDWF  40,W
0E30:  MOVWF  FE9
0E32:  MOVF   41,W
0E34:  ADDWFC 03,W
0E36:  MOVWF  FEA
0E38:  MOVF   42,W
0E3A:  SUBWF  FEF,W
0E3C:  SUBWF  x66,W
0E3E:  BZ    0E9C
0E40:  BNC   0E9C
0E42:  CLRF   03
0E44:  MOVF   3B,W
0E46:  ADDWF  40,W
0E48:  MOVWF  FE9
0E4A:  MOVF   41,W
0E4C:  ADDWFC 03,W
0E4E:  MOVWF  FEA
0E50:  MOVF   42,W
0E52:  ADDWF  FEF,W
0E54:  SUBWF  x66,W
0E56:  BC    0E9C
....................                   { 
....................                      for(i=pos, j=RFbuffer_index-1; j!=255; --i, --j) 
0E58:  MOVFF  67,68
0E5C:  MOVLW  01
0E5E:  SUBWF  3B,W
0E60:  MOVWF  x69
0E62:  INCFSZ x69,W
0E64:  BRA    0E68
0E66:  BRA    0E96
....................                      { 
....................                         if(RF_findWidths[j] != RF_findWidths[i]) 
0E68:  CLRF   03
0E6A:  MOVF   x69,W
0E6C:  ADDWF  40,W
0E6E:  MOVWF  FE9
0E70:  MOVF   41,W
0E72:  ADDWFC 03,W
0E74:  MOVWF  FEA
0E76:  MOVFF  FEF,6A
0E7A:  CLRF   03
0E7C:  MOVF   x68,W
0E7E:  ADDWF  40,W
0E80:  MOVWF  FE9
0E82:  MOVF   41,W
0E84:  ADDWFC 03,W
0E86:  MOVWF  FEA
0E88:  MOVF   FEF,W
0E8A:  SUBWF  x6A,W
0E8C:  BZ    0E90
....................                         { 
....................                            break; 
0E8E:  BRA    0E96
....................                         } 
0E90:  DECF   x68,F
0E92:  DECF   x69,F
0E94:  BRA    0E62
....................                      } 
....................                      if(j == 255) 
0E96:  INCFSZ x69,W
0E98:  BRA    0E9C
....................                      { 
....................                         break; 
0E9A:  BRA    0E9E
....................                      } 
....................                   } 
0E9C:  BRA    0E26
....................                } 
....................             } 
....................          } 
....................          break; 
....................       } 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       This interrupt service routine is used 
.................... //                to send data to a transponder 
.................... // Inputs:        None 
.................... // Outputs:       None 
0E9E:  BCF    F9E.2
0EA0:  GOTO   0078
.................... #INT_CCP2 
.................... void isr_ccp2() 
.................... { 
....................    static int1 mode = 1; 
....................  
....................    if(mode == 1 && !END_OF_RFBUFFER) 
*
0EC6:  BTFSS  3E.5
0EC8:  BRA    0F18
0ECA:  MOVF   3B,W
0ECC:  SUBLW  14
0ECE:  BZ    0F18
....................    { 
....................       // Output high to modulate the antenna, so send a 0 with modulation pin high 
....................       output_bit(RF_MOD, !bit_test(RFbuffer[RFbuffer_index], RFbuffer_bitIndex)); 
0ED0:  CLRF   03
0ED2:  MOVF   3B,W
0ED4:  ADDLW  27
0ED6:  MOVWF  FE9
0ED8:  MOVLW  00
0EDA:  ADDWFC 03,W
0EDC:  MOVWF  FEA
0EDE:  MOVFF  FEF,66
0EE2:  MOVFF  66,00
0EE6:  MOVF   3C,W
0EE8:  MOVWF  01
0EEA:  BZ    0EF4
0EEC:  BCF    FD8.0
0EEE:  RRCF   00,F
0EF0:  DECFSZ 01,F
0EF2:  BRA    0EEC
0EF4:  BTFSS  00.0
0EF6:  BRA    0EFC
0EF8:  BCF    F8A.2
0EFA:  BRA    0EFE
0EFC:  BSF    F8A.2
0EFE:  BCF    F93.2
....................  
....................       if(++RFbuffer_bitIndex == 8)   // Increment the buffer indexes as necessary 
0F00:  INCF   3C,F
0F02:  MOVF   3C,W
0F04:  SUBLW  08
0F06:  BNZ   0F0C
....................       { 
....................          RFbuffer_bitIndex = 0; 
0F08:  CLRF   3C
....................          ++RFbuffer_index; 
0F0A:  INCF   3B,F
....................       } 
....................  
....................       CCP_2 += 30;            // Wait for half the bit period minus two RF periods 
0F0C:  MOVLW  1E
0F0E:  ADDWF  FBB,F
0F10:  MOVLW  00
0F12:  ADDWFC FBC,F
....................       mode = 0;               // Toggle the mode 
0F14:  BCF    3E.5
....................    } 
0F16:  BRA    0F28
....................    else 
....................    { 
....................       output_low(RF_MOD);     // No modulation 
0F18:  BCF    F93.2
0F1A:  BCF    F8A.2
....................       CCP_2 += 34;            // Wait for half the bit period plus 2 RF periods before sending another bit 
0F1C:  MOVLW  22
0F1E:  ADDWF  FBB,F
0F20:  MOVLW  00
0F22:  ADDWFC FBC,F
....................       ++dataTransferred;      // Increment the bits transferred counter 
0F24:  INCF   44,F
....................       mode = 1;               // Toggle the mode 
0F26:  BSF    3E.5
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Interrupt for timer 0. Keeps track of the number of 
.................... //                overflows for timeouts. 
.................... // Inputs:        None 
.................... // Outputs:       None 
0F28:  BCF    FA1.0
0F2A:  GOTO   0078
.................... #INT_RTCC 
.................... void isr_rtcc() 
.................... { 
....................    ++timer0_overflows; 
0F2E:  INCF   43,F
0F30:  BCF    FF2.2
0F32:  GOTO   0078
.................... } 
....................  
....................  
.................... // Purpose:       Fill the buffer with data read from the basestation 
.................... // Inputs:        1) The number of bits to read 
.................... //                2) TRUE start on rising edge 
.................... //                   FALSE start on falling edge 
.................... // Outputs:       The number of bits read. Could be used to check for timeout 
.................... int8 RF_get(int8 numBits, int1 edge) 
.................... { 
....................    RF_readEdge(edge); 
*
119A:  MOVFF  59,5A
119E:  BRA    117C
....................    RF_readMode = RF_MANCHESTER_DATA; 
11A0:  CLRF   3D
....................  
....................    storeData         = TRUE; 
11A2:  BSF    3E.1
....................    bitValue          = 0; 
11A4:  BCF    3E.0
....................    RFbuffer_index    = 0; 
11A6:  CLRF   3B
....................    RFbuffer_bitIndex = 0; 
11A8:  CLRF   3C
....................    dataTransferred   = 0; 
11AA:  CLRF   44
....................    timer0_overflows  = 0; 
11AC:  CLRF   43
....................    old_clock         = 0; 
11AE:  CLRF   46
11B0:  CLRF   45
....................    set_timer1(0); 
11B2:  CLRF   FCF
11B4:  CLRF   FCE
....................  
....................    clear_interrupt(INT_CCP1); 
11B6:  BCF    F9E.2
....................    enable_interrupts(INT_CCP1); 
11B8:  BSF    F9D.2
....................    while(dataTransferred < numBits && timer0_overflows < 15); 
11BA:  MOVF   58,W
11BC:  SUBWF  44,W
11BE:  BC    11C6
11C0:  MOVF   43,W
11C2:  SUBLW  0E
11C4:  BC    11BA
....................    disable_interrupts(INT_CCP1); 
11C6:  BCF    F9D.2
....................  
....................    RFbuffer_index = 0; 
11C8:  CLRF   3B
....................    RFbuffer_bitIndex = 0; 
11CA:  CLRF   3C
....................  
....................    return dataTransferred; 
11CC:  MOVFF  44,01
11D0:  GOTO   1492 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Send data from the buffer to the transponder 
.................... // Inputs:        1) Send numBits of data to the transponder 
.................... //                2) The index in the buffer to start at 
.................... //                3) The bit position at the index to start at 
.................... // Outputs:       None 
.................... void RF_send(int8 numBits, int8 index, int8 bitPosition) 
.................... { 
....................    RFbuffer_index    = index; 
....................    RFbuffer_bitIndex = bitPosition; 
....................    dataTransferred   = 0; 
....................    CCP_2             = 3;  // 
....................    set_timer1(0);          // Cause an interrupt imediately 
....................  
....................    enable_interrupts(INT_CCP2); 
....................    while(dataTransferred < numBits); 
....................    disable_interrupts(INT_CCP2); 
.................... } 
....................  
....................  
.................... // Purpose:       Search for a certain pulse width 
.................... // Inputs:        1) The width length in clocks 
.................... //                2) Uncertainty to search over a range 
.................... //                3) TRUE start on rising edge 
.................... //                   FALSE start on falling edge 
.................... //                ex) numClocks = 128; uncertainty = 6; range = 122 to 134 
.................... // Outputs:       TRUE if width was found, FALSE if not found 
.................... int1 RF_findWidth(int8 numClocks, int8 uncertainty, int1 edge) 
.................... { 
....................    RF_readEdge(edge); 
....................  
....................    RF_readMode          = RF_FIND_WIDTH; 
....................    RF_widthToFind       = numClocks; 
....................    RF_widthFound        = FALSE; 
....................    RF_uncertainty       = uncertainty; 
....................    timer0_overflows     = 0; 
....................    old_clock            = 0; 
....................    set_timer1(0); 
....................  
....................    clear_interrupt(INT_CCP1); 
....................    enable_interrupts(INT_CCP1); 
....................    while(RF_widthFound == FALSE && timer0_overflows < 50); 
....................    disable_interrupts(INT_CCP1); 
....................  
....................    return RF_widthFound; 
.................... } 
....................  
....................  
.................... // Purpose:    Measure a number of pulse widths, both high and low 
.................... // Inputs:     1) The number of widths to measure 
.................... //             2) TRUE start on rising edge 
.................... //                FALSE start on falling edge 
.................... // Outputs:    The number of widths that were measured. If there is 
.................... //             no transponder in range, the timeout could occur. 
.................... int8 RF_measureWidths(int8 numWidths, int1 edge) 
.................... { 
....................    RF_readEdge(edge); 
....................  
....................    RF_readMode       = RF_MEASURE_WIDTHS; 
....................    dataTransferred   = 0; 
....................    RFbuffer_index    = 0; 
....................    timer0_overflows  = 0; 
....................    old_clock         = 0; 
....................    set_timer1(0); 
....................  
....................    clear_interrupt(INT_CCP1); 
....................    enable_interrupts(INT_CCP1); 
....................    while(dataTransferred < numWidths && timer0_overflows < 50); 
....................    disable_interrupts(INT_CCP1); 
....................  
....................    return dataTransferred; 
.................... } 
....................  
.................... // Purpose:    Measure a number of pulse widths, both high and low 
.................... // Inputs:     1) A pointer to an array of widths. It is safe to use RFbuffer. 
.................... //             2) The number of widths in the pattern 
.................... //             3) Uncertainty to search over a range 
.................... //             4) TRUE start on rising edge 
.................... //                FALSE start on falling edge 
.................... // Outputs:    The number of widths that were measured. If there is 
.................... //             no transponder in range, the timeout could occur. 
.................... int8 RF_findPattern(int8* widths, int8 numWidths, int8 uncertainty, int1 edge) 
.................... { 
....................    RF_readEdge(edge); 
....................  
....................    RF_readMode       = RF_FIND_PATTERN; 
....................    RF_patternFound   = FALSE; 
....................    RFbuffer_index    = 0; 
....................    RF_findWidths     = widths; 
....................    dataTransferred   = numWidths; 
....................    RF_uncertainty    = uncertainty; 
....................    timer0_overflows  = 0; 
....................    old_clock         = 0; 
....................    set_timer1(0); 
....................  
....................    clear_interrupt(INT_CCP1); 
....................    enable_interrupts(INT_CCP1); 
....................    while(RF_patternFound == FALSE && timer0_overflows < 40); 
....................    disable_interrupts(INT_CCP1); 
....................  
....................    return RF_patternFound; 
.................... } 
....................  
....................  
.................... // Purpose:       Set every byte in the buffer to data 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... void RFbuffer_fill(int8 data) 
.................... { 
....................    int i; 
....................  
....................    for(i=0; i<sizeof(RFbuffer); ++i) 
*
142C:  CLRF   59
142E:  MOVF   59,W
1430:  SUBLW  13
1432:  BNC   144A
....................    { 
....................       RFbuffer[i] = data; 
1434:  CLRF   03
1436:  MOVF   59,W
1438:  ADDLW  27
143A:  MOVWF  FE9
143C:  MOVLW  00
143E:  ADDWFC 03,W
1440:  MOVWF  FEA
1442:  MOVFF  58,FEF
1446:  INCF   59,F
1448:  BRA    142E
....................    } 
144A:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Inverts every byte in the buffer 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... void RFbuffer_invert() 
.................... { 
....................    int i; 
....................  
....................    for(i=0; i<sizeof(RFbuffer); ++i) 
144C:  CLRF   58
144E:  MOVF   58,W
1450:  SUBLW  13
1452:  BNC   1484
....................    { 
....................       RFbuffer[i] = ~RFbuffer[i]; 
1454:  CLRF   03
1456:  MOVF   58,W
1458:  ADDLW  27
145A:  MOVWF  01
145C:  MOVLW  00
145E:  ADDWFC 03,F
1460:  MOVFF  03,5A
1464:  CLRF   03
1466:  MOVF   58,W
1468:  ADDLW  27
146A:  MOVWF  FE9
146C:  MOVLW  00
146E:  ADDWFC 03,W
1470:  MOVWF  FEA
1472:  MOVF   FEF,W
1474:  XORLW  FF
1476:  MOVFF  5A,FEA
147A:  MOVFF  01,FE9
147E:  MOVWF  FEF
1480:  INCF   58,F
1482:  BRA    144E
....................    } 
1484:  GOTO   14C4 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Get a bit of data from the buffer and increment to the next bit 
.................... // Inputs:        None 
.................... // Ouputs:        A bit of data 
.................... int1 RFbuffer_getBit() 
.................... { 
....................    int1 bit; 
....................  
....................    if(!END_OF_RFBUFFER) 
*
11D4:  MOVF   3B,W
11D6:  SUBLW  14
11D8:  BZ    1210
....................    { 
....................       bit = bit_test(RFbuffer[RFbuffer_index], RFbuffer_bitIndex); 
11DA:  CLRF   03
11DC:  MOVF   3B,W
11DE:  ADDLW  27
11E0:  MOVWF  FE9
11E2:  MOVLW  00
11E4:  ADDWFC 03,W
11E6:  MOVWF  FEA
11E8:  MOVFF  FEF,5E
11EC:  MOVFF  5E,00
11F0:  MOVF   3C,W
11F2:  MOVWF  01
11F4:  BZ    11FE
11F6:  BCF    FD8.0
11F8:  RRCF   00,F
11FA:  DECFSZ 01,F
11FC:  BRA    11F6
11FE:  BCF    5D.0
1200:  BTFSC  00.0
1202:  BSF    5D.0
....................  
....................       if(++RFbuffer_bitIndex == 8) 
1204:  INCF   3C,F
1206:  MOVF   3C,W
1208:  SUBLW  08
120A:  BNZ   1210
....................       { 
....................          ++RFbuffer_index; 
120C:  INCF   3B,F
....................          RFbuffer_bitIndex = 0; 
120E:  CLRF   3C
....................       } 
....................    } 
....................  
....................    return bit; 
1210:  MOVLW  00
1212:  BTFSC  5D.0
1214:  MOVLW  01
1216:  MOVWF  01
1218:  RETURN 0
.................... } 
....................  
....................  
.................... // Purpose:       Get a byte of data from the buffer 
.................... // Inputs:        None 
.................... // Outputs:       The byte of data 
.................... int8 RFbuffer_getByte() 
.................... { 
....................    if(!END_OF_RFBUFFER) 
....................    { 
....................       int8 i; 
....................       int8 data; 
....................  
....................       for(i=0; i<8; ++i) 
....................       { 
....................          shift_right(&data, 1, RFbuffer_getBit()); 
....................       } 
....................  
....................       return data; 
....................    } 
.................... } 
....................  
....................  
.................... // Purpose:       Set the value of the next bit in the buffer 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... void RFbuffer_setBit(int1 bit) 
.................... { 
....................    if(!END_OF_RFBUFFER) 
....................    { 
....................       if(bit) 
....................       { 
....................          bit_set(RFbuffer[RFbuffer_index], RFbuffer_bitIndex); 
....................       } 
....................       else 
....................       { 
....................          bit_clear(RFbuffer[RFbuffer_index], RFbuffer_bitIndex); 
....................       } 
....................  
....................       if(++RFbuffer_bitIndex >= 8) 
....................       { 
....................          ++RFbuffer_index; 
....................          RFbuffer_bitIndex = 0; 
....................       } 
....................    } 
.................... } 
....................  
.................... // Purpose:       Set the value of the next byte in the buffer 
.................... // Inputs:        None 
.................... // Outputs:       None 
.................... void RFbuffer_setByte(int8 data) 
.................... { 
....................    if(!END_OF_RFBUFFER) 
....................    { 
....................       int8 i; 
....................       for(i=0; i<8; ++i) 
....................       { 
....................          RFbuffer_setBit(bit_test(data, 7)); 
....................          rotate_left(&data, 1); 
....................       } 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
.................... #include <em4102.c> 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////                            EM4102.c                             //// 
.................... ////                                                                 //// 
.................... //// This file contains drivers for a 4102 RF transponder            //// 
.................... ////                                                                 //// 
.................... //// int1 read_4102(int8* data)                                      //// 
.................... ////   - Call this funtion to read a 4102 transponder                //// 
.................... ////   - Pass in a pointer to a 5 byte array                         //// 
.................... ////   - The first byte will have the customer code and the last     //// 
.................... ////     four bytes will contain the ID number                       //// 
.................... ////                                                                 //// 
.................... ////   - Returns FALSE if a parity check error occurred              //// 
.................... ////   - Returns TRUE if a transponder was read successfully         //// 
.................... ////                                                                 //// 
.................... ///////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2004 Custom Computer Services         //// 
.................... //// This source code may only be used by licensed users of the CCS  //// 
.................... //// C compiler.  This source code may only be distributed to other  //// 
.................... //// licensed users of the CCS C compiler.  No other use,            //// 
.................... //// reproduction or distribution is permitted without written       //// 
.................... //// permission.  Derivative programs created using this software    //// 
.................... //// in object code form are not restricted in any way.              //// 
.................... ///////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef TRANSPONDER_4102_DRIVERS 
.................... #define TRANSPONDER_4102_DRIVERS 
....................  
.................... //#define UNIVERSAL_FORMAT 
....................  
.................... // Function Prototypes 
.................... int1 read_4102(int8* data); 
.................... int1 header_search_4102(); 
.................... int1 decode_data_4102(int8* data); 
....................  
....................  
.................... // Purpose:       Reads the ID number and data number 
.................... // Inputs:        A pointer to a 5 byte array to fill 
.................... //                * The first byte will have the ID 
.................... //                * The last 4 bytes will have the data 
.................... // Outputs:       TRUE if read successful, FALSE if read failed 
.................... int1 read_4102(int8* data) 
.................... { 
....................    int8 i; 
....................  
....................    RF_get(sizeof(RFbuffer)*8, TRUE);    // Fill the buffer with data 
*
1488:  MOVLW  A0
148A:  MOVWF  58
148C:  MOVLW  01
148E:  MOVWF  59
1490:  BRA    119A
....................  
....................    for(i=0; i<2; ++i) 
1492:  CLRF   57
1494:  MOVF   57,W
1496:  SUBLW  01
1498:  BNC   14C8
....................    { 
....................       while(!END_OF_RFBUFFER) 
149A:  MOVF   3B,W
149C:  SUBLW  14
149E:  BZ    14C2
....................       { 
....................          if(header_search_4102())       // Try to find 9 consecutive 1s 
14A0:  BRA    121A
14A2:  MOVF   01,F
14A4:  BZ    14C0
....................          { 
....................             if(decode_data_4102(data))  // Try to decode the data after the header 
14A6:  MOVFF  56,59
14AA:  MOVFF  55,58
14AE:  BRA    126C
14B0:  MOVF   01,F
14B2:  BZ    14C0
....................             { 
....................                RFbuffer_fill(0xAA);     // Prevents false detection 
14B4:  MOVLW  AA
14B6:  MOVWF  58
14B8:  RCALL  142C
....................                 
....................                #ifdef UNIVERSAL_FORMAT 
....................                   i=data[1]; 
....................                   data[1]=data[3]; 
....................                   data[3]=i; 
....................                   i=data[0]; 
....................                   data[0]=data[4]; 
....................                   data[4]=i; 
....................                #endif 
....................                 
....................                return TRUE;             // Return sucessful read 
14BA:  MOVLW  01
14BC:  MOVWF  01
14BE:  BRA    14D2
....................             } 
....................          } 
14C0:  BRA    149A
....................       } 
....................       RFbuffer_invert();                // Invert the buffer because the 
14C2:  BRA    144C
14C4:  INCF   57,F
14C6:  BRA    1494
....................    }                                    // Manchester encoded data could have 
....................                                         // been read starting at the wrong edge 
....................  
....................    RFbuffer_fill(0xAA);                 // Prevents false detection 
14C8:  MOVLW  AA
14CA:  MOVWF  58
14CC:  RCALL  142C
....................    return FALSE;                        // Return error 
14CE:  MOVLW  00
14D0:  MOVWF  01
14D2:  GOTO   16C8 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Search for the header consisting of 9 ones 
.................... // Inputs:        None 
.................... // Outputs:       TRUE if the header was found, FALSE if it was not found 
.................... int1 header_search_4102() 
*
121A:  CLRF   58
.................... { 
....................    int bitCounter = 0; 
....................  
....................    // Loops until 9 consecutive 1s are found 
....................    // or the end of the receive buffer is reached 
....................    while(!END_OF_RFBUFFER) 
121C:  MOVF   3B,W
121E:  SUBLW  14
1220:  BZ    123C
....................    { 
....................       if(RFbuffer_getBit() == 1) 
1222:  RCALL  11D4
1224:  DECFSZ 01,W
1226:  BRA    1238
....................       { 
....................          if(++bitCounter == 9) 
1228:  INCF   58,F
122A:  MOVF   58,W
122C:  SUBLW  09
122E:  BNZ   1236
....................          { 
....................             return TRUE; 
1230:  MOVLW  01
1232:  MOVWF  01
1234:  BRA    1240
....................          } 
....................       } 
1236:  BRA    123A
....................       else 
....................       { 
....................          bitCounter = 0; 
1238:  CLRF   58
....................       } 
123A:  BRA    121C
....................    } 
....................  
....................    return FALSE; 
123C:  MOVLW  00
123E:  MOVWF  01
1240:  GOTO   14A2 (RETURN)
.................... } 
....................  
....................  
.................... // Purpose:       Decodes the ID number and data number 
.................... // Inputs:        A pointer to a 5 byte array to fill 
.................... //                * The first byte will have the ID 
.................... //                * The last 4 bytes will have the data 
.................... // Outputs:       TRUE if read successful, FALSE if read failed 
.................... int1 decode_data_4102(int8* data) 
*
126C:  BCF    5A.0
126E:  MOVLW  01
1270:  MOVWF  5B
1272:  BCF    5A.1
1274:  BCF    5A.2
1276:  BCF    5A.3
1278:  BCF    5A.4
127A:  BCF    5A.5
.................... { 
....................    int1 bit = 0; 
....................    int8 count = 1; 
....................    int1 parity = 0; 
....................    int1 colParity1 = 0; 
....................    int1 colParity2 = 0; 
....................    int1 colParity3 = 0; 
....................    int1 colParity4 = 0; 
....................  
....................    // Loop until 40 bits of data and 10 bits of parity are received 
....................    for(count=1; count <= 50; ++count) 
127C:  MOVWF  5B
127E:  MOVF   5B,W
1280:  SUBLW  32
1282:  BTFSS  FD8.0
1284:  BRA    137C
....................    { 
....................       bit = RFbuffer_getBit(); 
1286:  RCALL  11D4
1288:  BCF    5A.0
128A:  BTFSC  01.0
128C:  BSF    5A.0
....................       if(END_OF_RFBUFFER) 
128E:  MOVF   3B,W
1290:  SUBLW  14
1292:  BNZ   129A
....................       { 
....................          return FALSE; 
1294:  MOVLW  00
1296:  MOVWF  01
1298:  BRA    13FC
....................       } 
....................  
....................       if(count % 5 == 0) 
129A:  MOVFF  5B,5C
129E:  MOVLW  05
12A0:  MOVWF  5D
12A2:  RCALL  1244
12A4:  MOVF   00,F
12A6:  BNZ   12C0
....................       { 
....................          // Check for row parity 
....................          if(parity != bit) 
12A8:  CLRF   00
12AA:  BTFSC  5A.0
12AC:  BSF    00.1
12AE:  MOVF   5A,W
12B0:  XORWF  00,W
12B2:  ANDLW  02
12B4:  BZ    12BC
....................          { 
....................             return FALSE; 
12B6:  MOVLW  00
12B8:  MOVWF  01
12BA:  BRA    13FC
....................          } 
....................          parity = 0; 
12BC:  BCF    5A.1
....................       } 
12BE:  BRA    1378
....................       else 
....................       { 
....................          // Store a bit of data 
....................          #ifdef UNIVERSAL_FORMAT 
....................          shift_left(data, 5, bit); 
....................          #else  
....................          shift_right(data, 5, bit); 
12C0:  BTFSC  5A.0
12C2:  BRA    12C8
12C4:  BCF    FD8.0
12C6:  BRA    12CA
12C8:  BSF    FD8.0
12CA:  MOVFF  59,FEA
12CE:  MOVFF  58,FE9
12D2:  MOVF   FEC,F
12D4:  MOVF   FEC,F
12D6:  MOVF   FEC,F
12D8:  MOVF   FEC,F
12DA:  RRCF   FED,F
12DC:  RRCF   FED,F
12DE:  RRCF   FED,F
12E0:  RRCF   FED,F
12E2:  RRCF   FED,F
....................          #endif 
....................           
....................          // Calculate row parity 
....................          parity ^= bit; 
12E4:  MOVLW  00
12E6:  BTFSC  5A.1
12E8:  MOVLW  01
12EA:  MOVWF  5C
12EC:  MOVLW  00
12EE:  BTFSC  5A.0
12F0:  MOVLW  01
12F2:  XORWF  5C,W
12F4:  BCF    5A.1
12F6:  BTFSC  FE8.0
12F8:  BSF    5A.1
....................  
....................          // Calculate column parity 
....................          switch (count % 5) 
12FA:  MOVFF  5B,5C
12FE:  MOVLW  05
1300:  MOVWF  5D
1302:  RCALL  1244
1304:  MOVF   00,W
1306:  ADDLW  FF
1308:  ADDLW  FC
130A:  BC    1378
130C:  ADDLW  04
130E:  GOTO   1400
....................          { 
....................             case 1: colParity1 ^= bit; break; 
1312:  MOVLW  00
1314:  BTFSC  5A.2
1316:  MOVLW  01
1318:  MOVWF  5C
131A:  MOVLW  00
131C:  BTFSC  5A.0
131E:  MOVLW  01
1320:  XORWF  5C,W
1322:  MOVWF  01
1324:  BCF    5A.2
1326:  BTFSC  FE8.0
1328:  BSF    5A.2
132A:  BRA    1378
....................             case 2: colParity2 ^= bit; break; 
132C:  MOVLW  00
132E:  BTFSC  5A.3
1330:  MOVLW  01
1332:  MOVWF  5C
1334:  MOVLW  00
1336:  BTFSC  5A.0
1338:  MOVLW  01
133A:  XORWF  5C,W
133C:  MOVWF  01
133E:  BCF    5A.3
1340:  BTFSC  FE8.0
1342:  BSF    5A.3
1344:  BRA    1378
....................             case 3: colParity3 ^= bit; break; 
1346:  MOVLW  00
1348:  BTFSC  5A.4
134A:  MOVLW  01
134C:  MOVWF  5C
134E:  MOVLW  00
1350:  BTFSC  5A.0
1352:  MOVLW  01
1354:  XORWF  5C,W
1356:  MOVWF  01
1358:  BCF    5A.4
135A:  BTFSC  FE8.0
135C:  BSF    5A.4
135E:  BRA    1378
....................             case 4: colParity4 ^= bit; break; 
1360:  MOVLW  00
1362:  BTFSC  5A.5
1364:  MOVLW  01
1366:  MOVWF  5C
1368:  MOVLW  00
136A:  BTFSC  5A.0
136C:  MOVLW  01
136E:  XORWF  5C,W
1370:  MOVWF  01
1372:  BCF    5A.5
1374:  BTFSC  FE8.0
1376:  BSF    5A.5
....................          } 
....................       } 
1378:  INCF   5B,F
137A:  BRA    127E
....................    } 
....................  
....................    // Check for column parity 
....................    if(colParity1 != RFbuffer_getBit() || colParity2 != RFbuffer_getBit() || 
....................       colParity3 != RFbuffer_getBit() || colParity4 != RFbuffer_getBit()   ) 
137C:  MOVLW  00
137E:  BTFSC  5A.2
1380:  MOVLW  01
1382:  MOVWF  5C
1384:  RCALL  11D4
1386:  MOVF   01,W
1388:  SUBWF  5C,W
138A:  BNZ   13BC
138C:  MOVLW  00
138E:  BTFSC  5A.3
1390:  MOVLW  01
1392:  MOVWF  5C
1394:  RCALL  11D4
1396:  MOVF   01,W
1398:  SUBWF  5C,W
139A:  BNZ   13BC
139C:  MOVLW  00
139E:  BTFSC  5A.4
13A0:  MOVLW  01
13A2:  MOVWF  5C
13A4:  RCALL  11D4
13A6:  MOVF   01,W
13A8:  SUBWF  5C,W
13AA:  BNZ   13BC
13AC:  MOVLW  00
13AE:  BTFSC  5A.5
13B0:  MOVLW  01
13B2:  MOVWF  5C
13B4:  RCALL  11D4
13B6:  MOVF   01,W
13B8:  SUBWF  5C,W
13BA:  BZ    13C2
....................    { 
....................       return FALSE; 
13BC:  MOVLW  00
13BE:  MOVWF  01
13C0:  BRA    13FC
....................    } 
....................  
....................    // Check for stop bit 
....................    if(RFbuffer_getBit() != 0) 
13C2:  RCALL  11D4
13C4:  MOVF   01,F
13C6:  BZ    13CE
....................    { 
....................       return FALSE; 
13C8:  MOVLW  00
13CA:  MOVWF  01
13CC:  BRA    13FC
....................    } 
....................  
....................    // Prevents reading all zeros for customer ID and tag ID 
....................    for(count=0; count<5 && data[count] == 0; ++count); 
13CE:  CLRF   5B
13D0:  MOVF   5B,W
13D2:  SUBLW  04
13D4:  BNC   13EC
13D6:  CLRF   03
13D8:  MOVF   5B,W
13DA:  ADDWF  58,W
13DC:  MOVWF  FE9
13DE:  MOVF   59,W
13E0:  ADDWFC 03,W
13E2:  MOVWF  FEA
13E4:  MOVF   FEF,F
13E6:  BNZ   13EC
13E8:  INCF   5B,F
13EA:  BRA    13D0
....................    if(count == 5) 
13EC:  MOVF   5B,W
13EE:  SUBLW  05
13F0:  BNZ   13F8
....................    { 
....................       return FALSE; 
13F2:  MOVLW  00
13F4:  MOVWF  01
13F6:  BRA    13FC
....................    } 
....................  
....................    // Return TRUE if no errors in decoding received transponder data 
....................    return TRUE; 
13F8:  MOVLW  01
13FA:  MOVWF  01
13FC:  GOTO   14B0 (RETURN)
.................... } 
....................  
.................... #endif 
....................  
....................  
....................  
.................... #FUSES NOWDT                    //No Watch Dog Timer 
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale 
.................... #FUSES NOBROWNOUT               //No brownout reset 
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O 
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode) 
.................... #FUSES PLL5 
.................... #FUSES CPUDIV1 
.................... #FUSES HSPLL 
.................... #FUSES NOWDT                    //No Watch Dog Timer  
.................... #FUSES WDT128                   //Watch Dog Timer uses 1:128 Postscale  
.................... #FUSES NOPROTECT                //Code not protected from reading  
.................... #FUSES BROWNOUT_NOSL            //Brownout enabled during operation, disabled during SLEEP  
.................... #FUSES BROWNOUT                 //Reset when brownout detected  
.................... #FUSES PUT                      //Power Up Timer  
.................... #FUSES NOCPD                    //No EE protection  
.................... #FUSES STVREN                   //Stack full/underflow will cause reset  
.................... #FUSES NODEBUG                  //No Debug mode for ICD  
.................... #FUSES NOLVP                    //No low voltage prgming, B3(PIC16) or B5(PIC18) used for I/O  
.................... #FUSES NOWRT                    //Program memory not write protected  
.................... #FUSES NOWRTD                   //Data EEPROM not write protected  
.................... #FUSES IESO                     //Internal External Switch Over mode enabled  
.................... #FUSES FCMEN                    //Fail-safe clock monitor enabled  
.................... #FUSES PBADEN                   //PORTB pins are configured as analog input channels on RESET  
.................... #FUSES NOWRTC                   //configuration not registers write protected  
.................... #FUSES NOWRTB                   //Boot block not write protected  
.................... #FUSES NOEBTR                   //Memory not protected from table reads  
.................... #FUSES NOEBTRB                  //Boot block not protected from table reads  
.................... #FUSES NOCPB                    //No Boot Block code protection  
.................... #FUSES MCLR                     //Master Clear pin enabled  
.................... #FUSES LPT1OSC                  //Timer1 configured for low-power operation  
.................... #FUSES NOXINST                  //Extended set extension and Indexed Addressing mode disabled (Legacy mode)  
....................  
.................... #use delay(clock=48000000) 
*
1084:  CLRF   FEA
1086:  MOVLW  56
1088:  MOVWF  FE9
108A:  MOVF   FEF,W
108C:  BZ    10AA
108E:  MOVLW  0F
1090:  MOVWF  01
1092:  CLRF   00
1094:  DECFSZ 00,F
1096:  BRA    1094
1098:  DECFSZ 01,F
109A:  BRA    1092
109C:  MOVLW  8F
109E:  MOVWF  00
10A0:  DECFSZ 00,F
10A2:  BRA    10A0
10A4:  NOP   
10A6:  DECFSZ FEF,F
10A8:  BRA    108E
10AA:  RETURN 0
.................... #use rs232(baud=9600,parity=N,xmit=PIN_C6,rcv=PIN_C7,bits=8,stream=PORT1) 
....................  
.................... #define USB_CONFIG_HID_TX_SIZE 5 
.................... #define USB_CONFIG_HID_RX_SIZE 5 
.................... #define USB_CONFIG_VID 0x04d8 
.................... #define USB_CONFIG_PID 0x0101 
.................... #define USB_HID_EP 1; 
....................  
.................... #define HW_ADC_CONFIG   ADC_CLOCK_INTERNAL 
.................... #define HW_ADC_CHANNEL  0 
.................... #define HW_ADC_PORTS    AN0 
.................... #define HW_INIT() setup_adc_ports(HW_ADC_PORTS); setup_comparator(NC_NC_NC_NC) 
....................     
.................... //#define USB_CON_SENSE_PIN  
.................... // PIN_A0, PIN_A1 - LED 
.................... // PIN_A3 - sound 
....................  
.................... #define LED_ON(x) output_high(x) 
.................... #define LED_OFF(x) output_low(x) 
.................... #define HIGH_A0 output_high(PIN_A0) 
.................... #define HIGH_A1 output_high(PIN_A1) 
.................... #define HIGH_A3 output_high(PIN_A3) 
.................... #define LOW_A0 output_low(PIN_A0) 
.................... #define LOW_A1 output_low(PIN_A1) 
.................... #define LOW_A3 output_low(PIN_A3) 
.................... // define pin UART 
....................  
.................... #define uart_printf  printf 
....................  
.................... //function prototype 
.................... void usb_debug_task(void); 
.................... int8 outbuffer[USB_CONFIG_HID_TX_SIZE]; // buffer  out 
.................... int8 inbuffer[USB_CONFIG_HID_RX_SIZE]; // buffer in 
....................  
.................... //int8 data[];  
.................... int8 size, res; 
....................  
....................  
.................... /* TODO: Use usb_put_packet() to transmit data to USB HID, 
.................... using USB_HID_ENDPONT for the endpoint and the payload size 
.................... needs to match USB_CONFIG_HID_TX_SIZE. Use usb_get_packet() 
.................... to read incomming data, using USB_HID_ENDPOINT for the 
.................... endpoint. usb_enumerated() can be used to see if connected to 
.................... a host and ready to communicate. */ 
.................... /*********************** usb_debug_task()*****************************/ 
.................... // 
.................... // When called periodically, displays debugging information over serial 
.................... // to display enumeration and connection states.  Also lights LED2 and LED3 
.................... // based upon enumeration and connection status. 
.................... void usb_debug_task(void) 
.................... { 
....................    static int8 last_connected; 
....................    static int8 last_enumerated; 
....................    int8 new_connected; 
....................    int8 new_enumerated; 
....................     
....................    new_connected = usb_attached(); // kiem tra xem device da duoc gan vao cac bus chua.no duoc goi lien tuc boi usb_task() 
*
111E:  MOVLW  01
1120:  MOVWF  55
....................    new_enumerated = usb_enumerated();// thuc hien 1 quy trinh de ket noi device voi host 
1122:  RCALL  1118
1124:  MOVFF  01,56
....................  
....................    if (new_connected && !last_connected) 
1128:  MOVF   55,F
112A:  BZ    113A
112C:  MOVF   53,F
112E:  BNZ   113A
....................       uart_printf("\r\n\nUSB connected, waiting for enumaration..."); 
1130:  MOVLW  36
1132:  MOVWF  FF6
1134:  MOVLW  0F
1136:  MOVWF  FF7
1138:  RCALL  1038
....................    if (!new_connected && last_connected) 
113A:  MOVF   55,F
113C:  BNZ   114C
113E:  MOVF   53,F
1140:  BZ    114C
....................       uart_printf("\r\n\nUSB disconnected, waiting for connection..."); 
1142:  MOVLW  64
1144:  MOVWF  FF6
1146:  MOVLW  0F
1148:  MOVWF  FF7
114A:  RCALL  1038
....................    if (new_enumerated && !last_enumerated) 
114C:  MOVF   56,F
114E:  BZ    115E
1150:  MOVF   54,F
1152:  BNZ   115E
....................       uart_printf("\r\n\nUSB enumerated by PC/HOST"); 
1154:  MOVLW  94
1156:  MOVWF  FF6
1158:  MOVLW  0F
115A:  MOVWF  FF7
115C:  RCALL  1038
....................    if (!new_enumerated && last_enumerated) 
115E:  MOVF   56,F
1160:  BNZ   1170
1162:  MOVF   54,F
1164:  BZ    1170
....................       uart_printf("\r\n\nUSB unenumerated by PC/HOST, waiting for enumeration..."); 
1166:  MOVLW  B2
1168:  MOVWF  FF6
116A:  MOVLW  0F
116C:  MOVWF  FF7
116E:  RCALL  1038
....................  
....................    last_connected = new_connected; 
1170:  MOVFF  55,53
....................    last_enumerated = new_enumerated; 
1174:  MOVFF  56,54
1178:  GOTO   16C0 (RETURN)
.................... } 
.................... void main() 
*
15E8:  CLRF   FF8
15EA:  BCF    FD0.7
15EC:  BSF    07.7
15EE:  CLRF   3B
15F0:  CLRF   3C
15F2:  BSF    3E.0
15F4:  BSF    3E.1
15F6:  BSF    3E.2
15F8:  BCF    3E.3
15FA:  BCF    3E.4
15FC:  CLRF   3F
15FE:  CLRF   41
1600:  CLRF   40
1602:  CLRF   42
1604:  CLRF   43
1606:  CLRF   44
1608:  CLRF   46
160A:  CLRF   45
160C:  BSF    3E.5
160E:  BSF    FB8.3
1610:  MOVLW  E1
1612:  MOVWF  FAF
1614:  MOVLW  04
1616:  MOVWF  FB0
1618:  MOVLW  A6
161A:  MOVWF  FAC
161C:  MOVLW  90
161E:  MOVWF  FAB
1620:  MOVF   FC1,W
1622:  ANDLW  C0
1624:  IORLW  0F
1626:  MOVWF  FC1
1628:  MOVLW  07
162A:  MOVWF  FB4
162C:  CLRF   1B
162E:  MOVLW  04
1630:  MOVWF  1C
1632:  MOVLW  0C
1634:  MOVWF  1D
1636:  CLRF   53
1638:  CLRF   54
.................... { 
....................    setup_adc_ports(HW_ADC_PORTS); 
163A:  MOVF   FC1,W
163C:  ANDLW  C0
163E:  IORLW  0E
1640:  MOVWF  FC1
....................   setup_adc(HW_ADC_CONFIG); 
1642:  MOVF   FC0,W
1644:  ANDLW  C0
1646:  IORLW  07
1648:  MOVWF  FC0
164A:  BCF    FC0.7
164C:  BSF    FC2.0
....................   set_adc_channel(HW_ADC_CHANNEL); 
164E:  MOVLW  00
1650:  MOVWF  01
1652:  MOVF   FC2,W
1654:  ANDLW  C3
1656:  IORWF  01,W
1658:  MOVWF  FC2
....................    output_low(PIN_C6); 
165A:  BCF    F94.6
165C:  BCF    F8B.6
....................    output_low(PIN_C7); 
165E:  BCF    F94.7
1660:  BCF    F8B.7
....................    set_tris_a(0x00); 
1662:  MOVLW  00
1664:  MOVWF  F92
....................    uart_printf("Init USB \r\n"); 
1666:  MOVLW  EE
1668:  MOVWF  FF6
166A:  MOVLW  0F
166C:  MOVWF  FF7
166E:  RCALL  1038
....................  //  usb_init(); // ham khoi tao ket noi phan cung no se tao ra mot vong lap vo han de ket noi device toi cac bus nhung khong co nghia la no da duoc host chap nhan ket noi 
....................    usb_init_cs();// ham nay khoi tao ket noi doi cho den khi co usb ket noi toi host 
1670:  BRA    107E
....................    
....................    uart_printf("Init RFID \r\n"); 
1672:  MOVLW  FA
1674:  MOVWF  FF6
1676:  MOVLW  0F
1678:  MOVWF  FF7
167A:  RCALL  1038
....................    LOW_A0; 
167C:  BCF    F92.0
167E:  BCF    F89.0
....................    LOW_A1; 
1680:  BCF    F92.1
1682:  BCF    F89.1
....................    rf_powerDown();  
1684:  BCF    F93.1
1686:  BSF    F8A.1
....................    delay_ms(100); 
1688:  MOVLW  64
168A:  MOVWF  56
168C:  RCALL  1084
....................    HIGH_A0; 
168E:  BCF    F92.0
1690:  BSF    F89.0
....................    HIGH_A1; 
1692:  BCF    F92.1
1694:  BSF    F89.1
....................    HIGH_A3; 
1696:  BCF    F92.3
1698:  BSF    F89.3
....................    rf_init();         
169A:  BRA    10AC
....................    rf_powerUp();          
169C:  BCF    F93.1
169E:  BCF    F8A.1
....................    delay_ms(200); 
16A0:  MOVLW  C8
16A2:  MOVWF  56
16A4:  RCALL  1084
....................    LOW_A0; 
16A6:  BCF    F92.0
16A8:  BCF    F89.0
....................    LOW_A1; 
16AA:  BCF    F92.1
16AC:  BCF    F89.1
....................    LOW_A3; 
16AE:  BCF    F92.3
16B0:  BCF    F89.3
....................    uart_printf("RFID Setting......\r\n"); 
16B2:  MOVLW  08
16B4:  MOVWF  FF6
16B6:  MOVLW  10
16B8:  MOVWF  FF7
16BA:  RCALL  1038
....................    while(TRUE) 
....................    { 
....................       usb_task(); 
16BC:  BRA    10F4
....................       usb_debug_task(); 
16BE:  BRA    111E
....................       if(read_4102(inbuffer)) 
16C0:  CLRF   56
16C2:  MOVLW  4C
16C4:  MOVWF  55
16C6:  BRA    1488
16C8:  MOVF   01,F
16CA:  BZ    1792
....................       { 
....................          disable_interrupts(GLOBAL); 
16CC:  BCF    FF2.6
16CE:  BCF    FF2.7
16D0:  BTFSC  FF2.7
16D2:  BRA    16CE
....................          HIGH_A3; 
16D4:  BCF    F92.3
16D6:  BSF    F89.3
....................          HIGH_A0; 
16D8:  BCF    F92.0
16DA:  BSF    F89.0
....................          LOW_A1; 
16DC:  BCF    F92.1
16DE:  BCF    F89.1
....................          size = sizeof(inbuffer); 
16E0:  MOVLW  05
16E2:  MOVWF  51
....................          uart_printf("Data RFID:\r\n"); 
16E4:  MOVLW  1E
16E6:  MOVWF  FF6
16E8:  MOVLW  10
16EA:  MOVWF  FF7
16EC:  RCALL  1038
....................          uart_printf("%u-%u-%u-%u-%u\r\n",inbuffer[0],inbuffer[1],inbuffer[2],inbuffer[3],inbuffer[4]);  
16EE:  MOVFF  4C,55
16F2:  MOVLW  1B
16F4:  MOVWF  56
16F6:  RCALL  14D6
16F8:  MOVLW  2D
16FA:  BTFSS  F9E.4
16FC:  BRA    16FA
16FE:  MOVWF  FAD
1700:  MOVFF  4D,55
1704:  MOVLW  1B
1706:  MOVWF  56
1708:  RCALL  14D6
170A:  MOVLW  2D
170C:  BTFSS  F9E.4
170E:  BRA    170C
1710:  MOVWF  FAD
1712:  MOVFF  4E,55
1716:  MOVLW  1B
1718:  MOVWF  56
171A:  RCALL  14D6
171C:  MOVLW  2D
171E:  BTFSS  F9E.4
1720:  BRA    171E
1722:  MOVWF  FAD
1724:  MOVFF  4F,55
1728:  MOVLW  1B
172A:  MOVWF  56
172C:  RCALL  14D6
172E:  MOVLW  2D
1730:  BTFSS  F9E.4
1732:  BRA    1730
1734:  MOVWF  FAD
1736:  MOVFF  50,55
173A:  MOVLW  1B
173C:  MOVWF  56
173E:  RCALL  14D6
1740:  MOVLW  0D
1742:  BTFSS  F9E.4
1744:  BRA    1742
1746:  MOVWF  FAD
1748:  MOVLW  0A
174A:  BTFSS  F9E.4
174C:  BRA    174A
174E:  MOVWF  FAD
....................          if(usb_enumerated()) 
1750:  RCALL  1118
1752:  MOVF   01,F
1754:  BZ    177A
....................          { 
....................             if(usb_put_packet(USB_HID_ENDPOINT, inbuffer, size, USB_DTS_TOGGLE)) 
1756:  MOVLW  01
1758:  MOVWF  55
175A:  CLRF   57
175C:  MOVLW  4C
175E:  MOVWF  56
1760:  CLRF   59
1762:  MOVFF  51,58
1766:  MOVLW  02
1768:  MOVWF  5A
176A:  BRA    1542
176C:  MOVF   01,F
176E:  BZ    177A
....................             { 
....................                uart_printf("Send data\r\n"); 
1770:  MOVLW  2C
1772:  MOVWF  FF6
1774:  MOVLW  10
1776:  MOVWF  FF7
1778:  RCALL  1038
....................             }          
....................          } 
....................          delay_ms(500); 
177A:  MOVLW  02
177C:  MOVWF  55
177E:  MOVLW  FA
1780:  MOVWF  56
1782:  RCALL  1084
1784:  DECFSZ 55,F
1786:  BRA    177E
....................          LOW_A3; 
1788:  BCF    F92.3
178A:  BCF    F89.3
....................          enable_interrupts(GLOBAL); 
178C:  MOVLW  C0
178E:  IORWF  FF2,F
....................       } 
1790:  BRA    179A
....................       else 
....................       { 
....................         HIGH_A1; 
1792:  BCF    F92.1
1794:  BSF    F89.1
....................         LOW_A0; 
1796:  BCF    F92.0
1798:  BCF    F89.0
....................       } 
179A:  BRA    16BC
....................       
....................    }; 
....................  
.................... } 
179C:  SLEEP 

Configuration Fuses:
   Word  1: CE24   PLL5 CPUDIV1 USBDIV HSPLL FCMEN IESO
   Word  2: 0E3E   PUT BROWNOUT BORV21 VREGEN NOWDT WDT128
   Word  3: 8700   CCP2C1 PBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
